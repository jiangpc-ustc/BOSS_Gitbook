  if(m_pion<0 || m_pion>10){std::cout<<"mode index for phokhar 0~10, but you give "<<m_pion<<std::endl;abort();}
  EvtId myvpho=EvtPDL::getId("vpho");
  m_E = p->mass();//EvtPDL::getMeanMass(myvpho);
///======== list parameters to be initialized
  m_tagged = 0;
  m_nm = 50000 ; // # of events to determine the maximum
  m_nlo = 1;     // Born(0), NLO(1)
  m_w = 0.0001;  // soft photon cutoff
  m_fsr = 0;     // ISR only(0), ISR+FSR(1), ISR+INT+FSR(2)
  m_fsrnlo = 0 ; // yes(1), no(0)
  m_NarrowRes = 0 ;// none(0) jpsi(1) psip(2)
  m_FF_Kaon = 2 ;  // constrained (0), unconstrained (1), Kuhn-Khodjamirian-Bruch (2)
  m_ivac = 1;      // yes(1), no(0)
  m_FF_Pion = 1 ;  // KS Pionformfactor(0), GS Pionformfactor old(1) and new(2)
  m_f0_model = 0 ; // f0+f0(600): KK model(0), no structure(1),  no f0+f0(600)(2), f0 KLOE(3)
  m_q2min = 0.0;   // minimal  hadrons(muons)-gamma-inv mass squared (GeV^2)
  m_q2_min_c = 0.0447 ; // minimal inv. mass squared of the hadrons(muons)(GeV^2)
  m_q2_max_c = m_E*m_E;    // maximal inv. mass squared of the hadrons(muons)(GeV^2)
  m_gmin = 0.001;       // minimal photon energy/missing energy   (GeV)
  m_phot1cut = 0.0;     // maximal photon angle/missing momentum angle (grad)
  m_phot2cut = 180.0;   // maximal photon angle/missing momentum angle (grad)
  m_pi1cut = 0.0 ;      // minimal hadrons(muons) angle (grad)
  m_pi2cut = 180.0;     // maximal hadrons(muons) angle (grad)
  m_sloppy = false;  //Ignore inconsistencies in parameter configuration (NOTRECOMMENDED)

  if(!(m_pion==0 || m_pion==1 || m_pion==6)){m_fsr = 0;  m_fsrnlo = 0 ;}
  if( m_pion==9 ){m_nlo = 0 ;}
  // --- input parameter initialization -----------
  maxima_.iprint = 0;
  flags_.ph0 =1; //only scan mode 
  flags_.nlo = m_nlo;
  flags_.pion = m_pion;
  flags_.fsr = m_fsr;
  flags_.fsrnlo = m_fsrnlo;
  flags_.ivac = m_ivac;
  flags_.FF_pion  = m_FF_Pion;
  flags_.f0_model = m_f0_model;
  flags_.FF_kaon  = m_FF_Kaon;
  flags_.narr_res = m_NarrowRes;
  flags_.FF_pp=0;

  ctes_.Sp = m_E*m_E;        ;

  cuts_.w = m_w;
  cuts_.q2min = m_q2min;
  cuts_.q2_min_c = m_q2_min_c;
  cuts_.q2_max_c = m_q2_max_c;
  cuts_.gmin = m_gmin;
  cuts_.phot1cut = m_phot1cut;
  cuts_.phot2cut = m_phot2cut;
  cuts_.pi1cut = m_pi1cut;
  cuts_.pi2cut = m_pi2cut;

  INPUT();

    cos1min = cos(cuts_.phot2cut*ctes_.pi/180.0);     // photon1 angle cuts in the 
    cos1max = cos(cuts_.phot1cut*ctes_.pi/180.0);     // LAB rest frame   
      cos2min = -1.0;                        // photon2 angle limits      
      cos2max =  1.0;                        //                           
      cos3min = -1.0;                        // hadrons/muons angle limits    
      cos3max =  1.0;                        // in their rest frame            
      if (flags_.pion == 0)                  // virtual photon energy cut 
        qqmin = 4.0*ctes_.mmu*ctes_.mmu;
      else if (flags_.pion == 1)
        qqmin = 4.0*ctes_.mpi*ctes_.mpi;
      else if (flags_.pion == 2)
        qqmin = 4.0*(ctes_.mpi+ctes_.mpi0)*(ctes_.mpi+ctes_.mpi0);
      else if (flags_.pion == 3)
        qqmin = 16.0*ctes_.mpi*ctes_.mpi;
      else if (flags_.pion == 4)
        qqmin = 4.0*ctes_.mp*ctes_.mp;
      else if (flags_.pion == 5)
        qqmin = 4.0*ctes_.mnt*ctes_.mnt;
      else if (flags_.pion == 6)
        qqmin = 4.0*ctes_.mKp*ctes_.mKp;
      else if (flags_.pion == 7)
        qqmin = 4.0*ctes_.mKn*ctes_.mKn;
      else if (flags_.pion == 8)
        qqmin = (2.0*ctes_.mpi+ctes_.mpi0)*(2.0*ctes_.mpi+ctes_.mpi0);
      else if (flags_.pion == 9)
        qqmin = 4.0*ctes_.mlamb*ctes_.mlamb;
      qqmax = ctes_.Sp-2.0*sqrt(ctes_.Sp)*cuts_.gmin;         // if only one photon 
      if (cuts_.q2_max_c < qqmax)
        qqmax=cuts_.q2_max_c;      // external cuts      

      // -------------------
      if ( (cuts_.q2_min_c > qqmin) && (cuts_.q2_min_c < (ctes_.Sp*(1.0-2.0*(cuts_.gmin/sqrt(ctes_.Sp)+cuts_.w))) ) )
        qqmin = cuts_.q2_min_c;
      else {
      }


 // =================================================
// --- finding the maximum -------------------------
      for(int i = 0; i<2; i++)
        {
          maxima_.Mmax[i] = 1.0;
          maxima_.gross[i] = 0.0;
          maxima_.klein[i] = 0.0;
        }

      if (flags_.nlo == 0)
        maxima_.Mmax[1]=0.0;   // only 1 photon events generated

      maxima_.tr[0] = 0.0;
      maxima_.tr[1] = 0.0;
      maxima_.count[0] = 0.0;
      maxima_.count[1] = 0.0;

      // --- for the second run ---
      maxima_.Mmax[0] = theMmax0; 
      maxima_.Mmax[1] = theMmax1; 
      if((flags_.pion == 1) && (flags_.fsrnlo == 1))
        maxima_.Mmax[1]=maxima_.Mmax[1]*1.5;
      if((flags_.pion == 0) && (flags_.fsrnlo == 1))
        maxima_.Mmax[1]=maxima_.Mmax[1]*1.5;

      if((flags_.pion == 0) && (flags_.fsr == 1) && (flags_.fsrnlo == 0))
        maxima_.Mmax[1]=maxima_.Mmax[1]*1.2;

      if((flags_.pion == 2) || (flags_.pion == 3)){
        maxima_.Mmax[0]=maxima_.Mmax[0]*1.1;
        maxima_.Mmax[1]=maxima_.Mmax[1]*1.1;
      }

      if(flags_.pion == 8){
        maxima_.Mmax[0]=maxima_.Mmax[0]*1.08;
        maxima_.Mmax[1]=maxima_.Mmax[1]*1.1;
      }
// --- end of the second run -----------------------

      maxima_.tr[0] = 0.0;
      maxima_.tr[1] = 0.0;
      maxima_.tr[2] = 0.0;
      maxima_.count[0] = 0.0;
      maxima_.count[1] = 0.0;
      maxima_.count[2] = 0.0;
