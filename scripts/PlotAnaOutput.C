/**
 * @brief    Simple plotting script for RhoPi analysis output.
 * @author   Remco de Boer 雷穆克 (r.e.deboer@students.uu.nl or remco.de.boer@ihep.ac.cn)
 * @date     October 25th, 2018
 * @remark   @b DEVELOPMENTAL
 *
 * @details  This macro generates some plots like ToF versus momentum from ROOT files generated by the `analysis` step of the BOSS framework. Comment certain loops in this source code if you do @a {not} want to generate them.
 */


// * ========================= * //
// * ------- LIBRARIES ------- * //
// * ========================= * //
#include <iostream>
#include "TCanvas.h"
#include "TSystem.h"
#include "TH1.h"
#include "TH1D.h"
#include "TH2D.h"
#include "TString.h"
#include "../inc/BOSSRootFile.h"
#include "../inc/RhopiRootFile.h"
using namespace AnaBranches;


// * ===================================== * //
// * ------- FUNCTION DECLARATIONS ------- * //
// * ===================================== * //
template<class T>
void SetBranchAddress(TTree*, const char*, T&);
void DrawAndSave(TTree*, const char*, const char* s = "", Option_t* o = "");
void DrawSaveAndDelete(TH1D*&, const char*);
void DrawSaveAndDelete(TH2D*&, const char*);


// * ============================= * //
// * ------- MAIN FUNCTION ------- * //
// * ============================= * //
void PlotAnaOutput()
{
	// * Load RhoPi ROOT analysis file *
	RhopiRootFile rhopi("../data/root/ana_rhopi_data_0.root");
	if(rhopi.IsZombie()) return;

	// * Some variables *
	Long64_t nEntries; // will be used when looping over TTrees

	// * Set png output directory *
	// ! Set these depending on which histograms you save
		gSystem->mkdir(Form("png"));
		gSystem->mkdir(Form("png/branches"));
		gSystem->mkdir(Form("png/tof1"));
		gSystem->mkdir(Form("png/tof2"));
		gSystem->mkdir(Form("png/fit4c"));
		gSystem->mkdir(Form("png/fit5c"));

	// * Generate inner barrel ToF plots *
		// * Create histograms
			TH2D* histTof1_e = new TH2D("tof1_e",
				"Inner barrel ToF (electron hypothesis);#it{p} (GeV/#it{c});ToF (ns)",
				80,   0.,  2., // momentum bins
				40, -20., 50.  // ToF difference bins
			);
			TH2D* histTof1_mu = new TH2D("tof1_mu",
				"Inner barrel ToF (muon hypothesis);#it{p} (GeV/#it{c});ToF (ns)",
				80,   0.,  2., // momentum bins
				40, -50., 50.  // ToF difference bins
			);
			TH2D* histTof1_pi = new TH2D("tof1_pi",
				"Inner barrel ToF (pion hypothesis);#it{p} (GeV/#it{c});ToF (ns)",
				80,   0.,  2., // momentum bins
				40, -30., 50.  // ToF difference bins
			);
			TH2D* histTof1_k = new TH2D("tof1_k",
				"Inner barrel ToF (kaon hypothesis);#it{p} (GeV/#it{c});ToF (ns)",
				80,    0.,  2., // momentum bins
				40, -250., 50.  // ToF difference bins
			);
			TH2D* histTof1_p = new TH2D("tof1_p",
				"Inner barrel ToF (proton hypothesis);#it{p} (GeV/#it{c});ToF (ns)",
				80,    0.,  2., // momentum bins
				40, -500., 50.  // ToF difference bins
			);
		// * Loop over tof1 TTree
			nEntries = rhopi.tof1()->GetEntries();
			std::cout << "Looping over " << nEntries << " entries in TTree \"" << rhopi.tof1()->GetName() << "\"" << std::endl;
			for (Long64_t i=0; i < nEntries; i++ ) {
				rhopi.tof1()->GetEntry(i);
				histTof1_e ->Fill(tof1::ptrk, 50*tof1::te);  // one ToF unit is 50 ns
				histTof1_mu->Fill(tof1::ptrk, 50*tof1::tmu); // one ToF unit is 50 ns
				histTof1_pi->Fill(tof1::ptrk, 50*tof1::tpi); // one ToF unit is 50 ns
				histTof1_k ->Fill(tof1::ptrk, 50*tof1::tk);  // one ToF unit is 50 ns
				histTof1_p ->Fill(tof1::ptrk, 50*tof1::tp);  // one ToF unit is 50 ns
			}
		// * Draw and save histograms
			DrawSaveAndDelete(histTof1_e,  "png/tof1/histTof1_e.png");
			DrawSaveAndDelete(histTof1_mu, "png/tof1/histTof1_mu.png");
			DrawSaveAndDelete(histTof1_pi, "png/tof1/histTof1_pi.png");
			DrawSaveAndDelete(histTof1_k,  "png/tof1/histTof1_k.png");
			DrawSaveAndDelete(histTof1_p,  "png/tof1/histTof1_p.png");

	// * Generate outer barrel ToF plots *
		// * Create histograms
			TH2D* histTof2_e = new TH2D("tof2_e",
				"Outer barrel ToF (electron hypothesis);#it{p} (GeV/#it{c});ToF (ns)",
				80,   0.,  2., // momentum bins
				40, -20., 50.  // ToF difference bins
			);
			TH2D* histTof2_mu = new TH2D("tof2_mu",
				"Outer barrel ToF (muon hypothesis);#it{p} (GeV/#it{c});ToF (ns)",
				80,   0.,  2., // momentum bins
				40, -50., 50.  // ToF difference bins
			);
			TH2D* histTof2_pi = new TH2D("tof2_pi",
				"Outer barrel ToF (pion hypothesis);#it{p} (GeV/#it{c});ToF (ns)",
				80,   0.,  2., // momentum bins
				40, -30., 50.  // ToF difference bins
			);
			TH2D* histTof2_k = new TH2D("tof2_k",
				"Outer barrel ToF (kaon hypothesis);#it{p} (GeV/#it{c});ToF (ns)",
				80,    0.,  2., // momentum bins
				40, -250., 50.  // ToF difference bins
			);
			TH2D* histTof2_p = new TH2D("tof2_p",
				"Outer barrel ToF (proton hypothesis);#it{p} (GeV/#it{c});ToF (ns)",
				80,    0.,  2., // momentum bins
				40, -500., 50.  // ToF difference bins
			);
		// * Loop over tof2 TTree
			nEntries = rhopi.tof2()->GetEntries();
			std::cout << "Looping over " << nEntries << " entries in TTree \"" << rhopi.tof2()->GetName() << "\"" << std::endl;
			for (Long64_t i=0; i < nEntries; i++ ) {
				rhopi.tof2()->GetEntry(i);
				histTof2_e ->Fill(tof2::ptrk, 50*tof2::te);  // one ToF unit is 50 ns
				histTof2_mu->Fill(tof2::ptrk, 50*tof2::tmu); // one ToF unit is 50 ns
				histTof2_pi->Fill(tof2::ptrk, 50*tof2::tpi); // one ToF unit is 50 ns
				histTof2_k ->Fill(tof2::ptrk, 50*tof2::tk);  // one ToF unit is 50 ns
				histTof2_p ->Fill(tof2::ptrk, 50*tof2::tp);  // one ToF unit is 50 ns
			}
		// * Draw and save histograms
			DrawSaveAndDelete(histTof2_e,  "png/tof2/histTof2_e.png");
			DrawSaveAndDelete(histTof2_mu, "png/tof2/histTof2_mu.png");
			DrawSaveAndDelete(histTof2_pi, "png/tof2/histTof2_pi.png");
			DrawSaveAndDelete(histTof2_k,  "png/tof2/histTof2_k.png");
			DrawSaveAndDelete(histTof2_p,  "png/tof2/histTof2_p.png");

	// * Fit 4 inv. mass plots (pi^0) *
		// * Create histogram
			TH1D* histFit4c_mpi0 = new TH1D("fit4c_mpi0",
				"Invariant mass as determined with fit4c (#pi^0 candidate);#it{M_{#gamma#gamma}} (GeV/#it{c}^{2});counts",
				150, 0., .25
			);
		// * Loop over tof2 TTree
			nEntries = rhopi.fit4c()->GetEntries();
			std::cout << "Looping over " << nEntries << " entries in TTree \"" << rhopi.fit4c()->GetName() << "\"" << std::endl;
			for (Long64_t i=0; i < nEntries; i++ ) {
				rhopi.fit4c()->GetEntry(i);
				histFit4c_mpi0->Fill(fit4c::mpi0);
			}
		// * Draw and save histograms
			DrawSaveAndDelete(histFit4c_mpi0, "png/fit4c/histFit4c_mpi0.png");

	// * Fit 5 inv. mass plots (rho^0, rho^+, and rho^-) *
		// * Create histogram
			TH1D* histFit5c_mrho0 = new TH1D("fit5c_mrho0",
				"Invariant mass as determined with fit5c (#rho^{0} candidate);#it{M_{#pi^{-}#pi^{+}}} (GeV/#it{c}^{2});counts",
				150, 0.3, 3.
			);
			TH1D* histFit5c_mrhom = new TH1D("fit5c_mrhom",
				"Invariant mass as determined with fit5c (#rho^{-} candidate);#it{M_{#pi^{0}#pi^{-}}} (GeV/#it{c}^{2});counts",
				150, 0.3, 3.
			);
			TH1D* histFit5c_mrhop = new TH1D("fit5c_mrhop",
				"Invariant mass as determined with fit5c (#rho^{+} candidate);#it{M_{#pi^{0}#pi^{+}}} (GeV/#it{c}^{2});counts",
				150, 0.3, 3.
			);
			TH2D* histFit5c_dalitz_rhom_rho0 = new TH2D("fit5c_dalitz_rhom_rho0",
				"Dalitz plot (#rho^{-} vs #rho^{0} candidate);#it{M_{#pi^{0}#pi^{-}}} (GeV/#it{c}^{2});#it{M_{#pi^{-}#pi^{+}}} (GeV/#it{c}^{2});counts",
				80, 0.3, 3.,
				80, 0.3, 3.
			);
			TH2D* histFit5c_dalitz_rhop_rho0 = new TH2D("fit5c_dalitz_rhop_rho0",
				"Dalitz plot (#rho^{+} vs #rho^{0} candidate);#it{M_{#pi^{0}#pi^{+}}} (GeV/#it{c}^{2});#it{M_{#pi^{-}#pi^{+}}} (GeV/#it{c}^{2});counts",
				80, 0.3, 3.,
				80, 0.3, 3.
			);
			TH2D* histFit5c_dalitz_rhom_rhop = new TH2D("fit5c_dalitz_rhom_rhop",
				"Dalitz plot (#rho^{-} vs #rho^{+} candidate);#it{M_{#pi^{0}#pi^{-}}} (GeV/#it{c}^{2});#it{M_{#pi^{0}#pi^{+}}} (GeV/#it{c}^{2});counts",
				80, 0.3, 3.,
				80, 0.3, 3.
			);
		// * Loop over tof2 TTree
			nEntries = rhopi.fit5c()->GetEntries();
			std::cout << "Looping over " << nEntries << " entries in TTree \"" << rhopi.fit5c()->GetName() << "\"" << std::endl;
			for (Long64_t i=0; i < nEntries; i++ ) {
				rhopi.fit5c()->GetEntry(i);
				histFit5c_mrho0->Fill(fit5c::mrho0);
				histFit5c_mrhom->Fill(fit5c::mrhom);
				histFit5c_mrhop->Fill(fit5c::mrhop);
				histFit5c_dalitz_rhom_rho0->Fill(fit5c::mrhom, fit5c::mrho0);
				histFit5c_dalitz_rhop_rho0->Fill(fit5c::mrhop, fit5c::mrho0);
				histFit5c_dalitz_rhom_rhop->Fill(fit5c::mrhom, fit5c::mrhop);
			}
		// * Draw and save histograms
			DrawSaveAndDelete(histFit5c_mrho0, "png/fit5c/histFit5c_mrho0.png");
			DrawSaveAndDelete(histFit5c_mrhom, "png/fit5c/histFit5c_mrhom.png");
			DrawSaveAndDelete(histFit5c_mrhop, "png/fit5c/histFit5c_mrhop.png");
			DrawSaveAndDelete(histFit5c_dalitz_rhom_rho0, "png/fit5c/histFit5c_dalitz_rhom_rho0.png");
			DrawSaveAndDelete(histFit5c_dalitz_rhop_rho0, "png/fit5c/histFit5c_dalitz_rhop_rho0.png");
			DrawSaveAndDelete(histFit5c_dalitz_rhom_rhop, "png/fit5c/histFit5c_dalitz_rhom_rhop.png");

	// * TEMP *
		// // * Get entry
		// chain_da->GetEntry(i);
		// // * Compute 4-momenta
		// gam0.SetPxPyPzE(Pgam_5c[0][0], Pgam_5c[0][1], Pgam_5c[0][2], Pgam_5c[0][3]); // first gamma
		// gam1.SetPxPyPzE(Pgam_5c[1][0], Pgam_5c[1][1], Pgam_5c[1][2], Pgam_5c[1][3]); // second gamma
		// // gam0_mc.SetPxPyPzE(Pgam_mc[0][0], Pgam_mc[0][1], Pgam_mc[0][2], Pgam_mc[0][3]);
		// // gam1_mc.SetPxPyPzE(Pgam_mc[1][0], Pgam_mc[1][1], Pgam_mc[1][2], Pgam_mc[1][3]);
		// ppim.SetPxPyPzE(Ppim_5c[0],Ppim_5c[1],Ppim_5c[2],Ppim_5c[3]);
		// ppip.SetPxPyPzE(Ppip_5c[0],Ppip_5c[1],Ppip_5c[2],Ppip_5c[3]);
		// pi0 = gam0+gam1;
		// // * Compute invariant mass of the f0(1070) resonance
		// mpi0  = (gam0+gam1).M();
		// mrho0 = (ppim+ppip).M();
		// mrhop = (ppip+pi0) .M();
		// mrhom = (pi0+ppim) .M();
		// // mrhom = (ppim+gam0+gam1).M();
		// // mrhop = (ppip+gam0+gam1).M();
		// // * Apply cuts
		// if(chisq>20) continue;
		// if(fabs(mpi0-Mpi0)>0.015) continue;
		// // if(fabs(mrho0-Mrho0)>0.15) continue;
		// if(EP_pip>0.8 || EP_pim>0.8) continue;
		// // Ppi0   = sqrt(pi0.E()*pi0.E()-Mpi0*Mpi0);
		// // costhe = fabs(gam1_mc.E()-gam0_mc.E())/Ppi0;
		// // h_Ppi0-      >Fill(Ppi0);
		// // h_costhe    ->Fill(costhe);
		// // h_Ppi0      ->Fill(Ppi0);
		// // h_costhe_run->Fill(costhe, run);
		// // * Fill histogram
		// h_mrho0_da->Fill(mrho0);
		// h_mrhom_da->Fill(mrhom);
		// h_mrhop_da->Fill(mrhop);
		// h_mpi0_da ->Fill(mpi0);
		// h_dalitz  ->Fill(mrhom, mrhop);
		// // h_Egam_da->Fill(min2(gam0_mc.E(), gam1_mc.E()));
		// ++nCut1;


	// * Draw and save branches with a simple method *
		// * Vertex position (vxyz / m_tuple1)
			// DrawAndSave(rhopi.vxyz(),   "vx0");
			// DrawAndSave(rhopi.vxyz(),   "vy0");
			// DrawAndSave(rhopi.vxyz(),   "vz0");
			// DrawAndSave(rhopi.vxyz(),   "vr0");
			// DrawAndSave(rhopi.vxyz(),   "rvxy0");
			// DrawAndSave(rhopi.vxyz(),   "rvz0");
			// DrawAndSave(rhopi.vxyz(),   "rvphi0");
		// * Photon information (photon / m_tuple2)
			// DrawAndSave(rhopi.photon(), "dthe");
			// DrawAndSave(rhopi.photon(), "dphi");
			// DrawAndSave(rhopi.photon(), "dang");
			// DrawAndSave(rhopi.photon(), "eraw");
		// * dE/dx PID information (dedx / m_tuple7)
			// DrawAndSave(rhopi.dedx(),   "ptrk");
			// DrawAndSave(rhopi.dedx(),   "chie");
			// DrawAndSave(rhopi.dedx(),   "chimu");
			// DrawAndSave(rhopi.dedx(),   "chipi");
			// DrawAndSave(rhopi.dedx(),   "chik");
			// DrawAndSave(rhopi.dedx(),   "chip");
			// DrawAndSave(rhopi.dedx(),   "probPH");
			// DrawAndSave(rhopi.dedx(),   "normPH");
			// DrawAndSave(rhopi.dedx(),   "ghit");
			// DrawAndSave(rhopi.dedx(),   "thit");
		// * ToF inner barrel information (tof1 / m_tuple9)
			// DrawAndSave(rhopi.tof1(),   "ptrk");
			// DrawAndSave(rhopi.tof1(),   "cntr");
			// DrawAndSave(rhopi.tof1(),   "ph");
			// DrawAndSave(rhopi.tof1(),   "zhit");
			// DrawAndSave(rhopi.tof1(),   "qual");
			// DrawAndSave(rhopi.tof1(),   "te");
			// DrawAndSave(rhopi.tof1(),   "tmu");
			// DrawAndSave(rhopi.tof1(),   "tpi");
			// DrawAndSave(rhopi.tof1(),   "tk");
			// DrawAndSave(rhopi.tof1(),   "tp");
		// * ToF outer barrel information (tof2 / m_tuple10)
			// DrawAndSave(rhopi.tof2(),   "ptrk");
			// DrawAndSave(rhopi.tof2(),   "cntr");
			// DrawAndSave(rhopi.tof2(),   "ph");
			// DrawAndSave(rhopi.tof2(),   "zhit");
			// DrawAndSave(rhopi.tof2(),   "qual");
			// DrawAndSave(rhopi.tof2(),   "te");
			// DrawAndSave(rhopi.tof2(),   "tmu");
			// DrawAndSave(rhopi.tof2(),   "tpi");
			// DrawAndSave(rhopi.tof2(),   "tk");
			// DrawAndSave(rhopi.tof2(),   "tp");
		// * Particle Identification (pid / m_tuple11)
			// DrawAndSave(rhopi.pid(),    "ptrk");
			// DrawAndSave(rhopi.pid(),    "cost");
			// DrawAndSave(rhopi.pid(),    "dedx");
			// DrawAndSave(rhopi.pid(),    "tof1");
			// DrawAndSave(rhopi.pid(),    "tof2");
			// DrawAndSave(rhopi.pid(),    "prob");
		// * Total energy (etot / m_tuple3)
			// DrawAndSave(rhopi.etot(),   "m2gg");
			// DrawAndSave(rhopi.etot(),   "etot");
		// * Fit pi^0 information from EMCal (fit4c / m_tuple4)
			// DrawAndSave(rhopi.fit4c(),  "chi2");
			// DrawAndSave(rhopi.fit4c(),  "mpi0");
		// * Fit rho^0, rho^+, rho^- inv. mass from EMCal (fit5c / m_tuple5)
			// DrawAndSave(rhopi.fit5c(),  "chi2");
			// DrawAndSave(rhopi.fit5c(),  "mrh0");
			// DrawAndSave(rhopi.fit5c(),  "mrhp");
			// DrawAndSave(rhopi.fit5c(),  "mrhm");
		// * Photon detection efficiency info (geff / m_tuple6)
			// DrawAndSave(rhopi.geff(),   "fcos");
			// DrawAndSave(rhopi.geff(),   "elow");
		// * ToF end cap information (tofe / m_tuple8)
			// DrawAndSave(rhopi.tofe(),   "ptrk");
			// DrawAndSave(rhopi.tofe(),   "cntr");
			// DrawAndSave(rhopi.tofe(),   "ph");
			// DrawAndSave(rhopi.tofe(),   "rhit");
			// DrawAndSave(rhopi.tofe(),   "qual");
			// DrawAndSave(rhopi.tofe(),   "te");
			// DrawAndSave(rhopi.tofe(),   "tmu");
			// DrawAndSave(rhopi.tofe(),   "tpi");
			// DrawAndSave(rhopi.tofe(),   "tk");
			// DrawAndSave(rhopi.tofe(),   "tp");
}


// * ==================================== * //
// * ------- FUNCTION DEFINITIONS ------- * //
// * ==================================== * //
template<class T>
void SetBranchAddress(TTree* tree, const char* branchName, T& address)
{
	if(!tree) {
		std::cout << "ERROR: TTree* is a nullpointer" << std::endl;
		std::terminate();
	}
	if(tree->SetBranchAddress(branchName, &address)) {
		std::cout << "ERROR: Branch \"" << branchName << "\" does not exist in TTree \"" << tree->GetName() << "\"" << std::endl;
		std::terminate();
	}
}
void DrawAndSave(TTree* tree, const char* varexp, const char* selection, Option_t* option)
{
	TCanvas* c = new TCanvas();
	tree->Draw(varexp, selection, option);
	TString outputFileName("png/branches/");
	outputFileName += tree->GetName();
	outputFileName += "_";
	outputFileName += varexp;
	outputFileName += ".png";
	c->SaveAs(outputFileName.Data());
	c->Close();
}
void DrawSaveAndDelete(TH1D*& hist, const char* saveas)
{
	if(!hist) {
		std::cout << "ERROR: fed a nullpointer to DrawSaveAndDelete" << std::endl;
		return;
	}
	TCanvas *c = new TCanvas();
	hist->Draw("ep");
	c->SaveAs(saveas);
	delete c;
	delete hist;
	hist = NULL;
}
void DrawSaveAndDelete(TH2D*& hist, const char* saveas)
{
	if(!hist) {
		std::cout << "ERROR: fed a nullpointer to DrawSaveAndDelete" << std::endl;
		return;
	}
	TCanvas *c = new TCanvas();
	hist->Draw("colz");
	c->SaveAs(saveas);
	delete c;
	delete hist;
	hist = NULL;
}


int main()
{
	PlotAnaOutput();
	return 0;
}