#ifndef Physics_Analysis_BOSSRootFile_H
#define Physics_Analysis_BOSSRootFile_H

/**
 * @brief    General container for BOSS analysis output
 * @author   Remco de Boer 雷穆克 (r.e.deboer@students.uu.nl or remco.de.boer@ihep.ac.cn)
 * @date     October 24th, 2018
 * @remark   @b DEVELOPMENTAL
 *
 * @details  The BOSSRootTree class can be used to create several trees from ROOT files generated by the `jopOptions_ana` (analysis) step of the BOSS framework in the most general way, that is, it only loads the ROOT files and creates an `unordered_map` of `TTree`s based on @a (all) trees within those ROOT files. You can create a derived class which maps the map of `TTree`s to a structure with particular names that match the file with which you are working.
 */

// * ========================= * //
// * ------- LIBRARIES ------- * //
// * ========================= * //
	#include "FrameworkSettings.h"
	#include "TChainLoader.h"
	#include "TCanvas.h"
	#include "TFile.h"
	#include "TH1D.h"
	#include "TH2D.h"
	#include "TKey.h"
	#include "TList.h"
	#include "TObject.h"
	#include "TString.h"
	#include "TSystem.h"
	#include "TTree.h"
	#include <iostream>
	#include <string>
	#include <utility>
	#include <list>
	#include <map>
	#include <unordered_map>
	#include <math.h>



// * ================================ * //
// * ------- CLASS DEFINITION ------- * //
// * ================================ * //

	class BOSSRootFile
	{
	public:
		// * CONSTRUCTOR AND DESTRUCTORS * //
		BOSSRootFile();
		BOSSRootFile(const char* filename, bool print = true);
		~BOSSRootFile();
		void CloseFile();

		// * INFORMATION * //
		TH1F* DrawBranches(const char* treeName, const char* branchX, const Int_t nBinx, const double x1, const double x2, Option_t* opt="", const TString &setLogx="");
		TH2F* DrawBranches(const char* treeName, const char* branchX, const char* branchY, const Int_t nBinx, const double x1, const double x2, const Int_t nBiny, const double y1, const double y2, Option_t* opt="", const TString &setLogx="");
		bool IsZombie();
		void DrawAndSaveAllBranches(const char* treeName, Option_t* opt="", const TString &logScale="");
		void DrawBranches(const char* treeName, const char* branchNames, Option_t* opt="", const TString &logScale="");
		void Print();
		void Print(const char* nameOfTree, Option_t *opt = "toponly");
		void PrintCutFlow();
		void PrintTrees(Option_t *opt="");
		void QuickDrawAndSaveAll(Option_t* opt="");

		// * GETTERS * //
		Long64_t GetEntries(const char* treeName);
		Long64_t GetLargestEntries() const;
		TChainLoader& operator[](const char* name) { return fTrees.at(name); }
		TTree* FindTree(const char* treeName, bool terminate = false);
		std::unordered_map<std::string, TChainLoader>& GetTChainLoaders() { return fTrees; }

	protected:
		// * DATA MEMBERS * //
		TFile fFile; //!< The `TFile` that has been loaded.
		std::unordered_map<std::string, TChainLoader> fTrees; //!< Map of pointers to all `TTree`s in the ROOT file.

		// * PRIVATE METHODS * //
		bool OpenFile(const char*);
		std::list<TChainLoader*> CreateOrderedMap();
		template<class T> int SetBranchAddress(TTree* tree, const char* branchName, T& address);
		void Destruct();
		void Initialize();
		void LoadTrees(bool print = true);

	};



// * =========================================== * //
// * ------- CONSTRUCTORS AND DESTRUCTORS ------ * //
// * =========================================== * //

	/**
	 * @brief Default constructor.
	 * @details Currently does nothing as there are no null pointers to set.
	 */
	BOSSRootFile::BOSSRootFile()
	{
		Initialize();
	}

	/**
	 * @brief Constructor that opens a `TFile` and unordered_maps its contents.
	 */
	BOSSRootFile::BOSSRootFile(const char* filename, bool print) : fFile(filename)
	{
		// * Initialize members (empty them) *
		Initialize();
		// * Load TTrees *
		LoadTrees(print);
	}

	/**
	 * @brief Destructor that closes the `TFile` if needed.
	 */
	BOSSRootFile::~BOSSRootFile()
	{
		Destruct();
	}


	/**
	 * @brief Close file
	 */
	void BOSSRootFile::CloseFile()
	{
		fFile.Close();
		fTrees.clear();
	}



// * ======================= * //
// * ------- GETTERS ------- * //
// * ======================= * //

	/**
	 * @brief Get the number of events in one of the `TTree`s.
	 * @param treeName Name of the `TTree` that you are looking for.
	 * @return Tree object that contains the trees. Returns a `nullptr` if this `TTree` does not exist.
	 */
	Long64_t BOSSRootFile::GetEntries(const char* treeName)
	{
		TTree* tree = FindTree(treeName);
		if(tree) return tree->GetEntries();
		return 0;
	}

	/**
	 * @brief Return the largest number of events in all of the `TTree`s in the loaded ROOT file.
	 */
	Long64_t BOSSRootFile::GetLargestEntries() const
	{
		Long64_t largest = 0;
		for(auto it = fTrees.begin(); it != fTrees.end(); ++it)
			if(it->second.GetEntries() > largest)
				largest = it->second.GetEntries();
		return largest;
	}

	/**
	 * @brief Look for a tree in the files and get its `TTree`.
	 * @param treeName Name of the `TTree` that you are looking for.
	 * @param terminate Set to `true` if you want to terminate the entire programme if the `TTree` is not found. This can be useful if you want to avoid segmenation violations later.
	 * @return TTree* Tree object that contains the trees. Returns a `nullptr` if this `TTree` does not exist.
	 */
	TTree* BOSSRootFile::FindTree(const char* treeName, bool terminate)
	{
		if(terminate) return fTrees.at(treeName).Get();
		else          return fTrees[treeName].Get();
	}



// * =========================== * //
// * ------- INFORMATION ------- * //
// * =========================== * //

	/**
	 * @brief Draw the distributions of all branches available in the ROOT file.
	 * 
	 * @param treeName Name of the `TTree` that you are looking for.
	 * @param branchX Branch that you want to plot. You may use a formula.
	 * @param nBinx Number of bins to use on the \f$x\f$-axis.
	 * @param x1 Lower limit on the \f$x\f$-axis.
	 * @param x2 Upper limit on the \f$x\f$-axis..
	 * @param opt Draw options.
	 * @param logScale If this argument contains an `'x'`, the \f$x\f$-scale will be set to log scale (same for `'y'` and `'z'`).
	 */
	TH1F* BOSSRootFile::DrawBranches(const char* treeName, const char* branchX, const Int_t nBinx, const double x1, const double x2, Option_t* opt, const TString &logScale)
	{
		return fTrees.at(treeName).DrawBranches(branchX, nBinx, x1, x2, true, opt, logScale);
	}


	/**
	 * @brief Draw the distributions of all branches available in the ROOT file.
	 * 
	 * @param treeName Name of the `TTree` that you are looking for.
	 * @param branchX Branch that you want to plot on the \f$x\f$-axis. You may use a formula.
	 * @param branchY Branch that you want to plot on the \f$y\f$-axis. You may use a formula.
	 * @param nBinx Number of bins to use on the \f$x\f$-axis.
	 * @param x1 Lower limit on the \f$x\f$-axis.
	 * @param x2 Upper limit on the \f$x\f$-axis.
	 * @param nBiny Number of bins to use on the \f$y\f$-axis.
	 * @param y1 Lower limit on the \f$y\f$-axis.
	 * @param y2 Upper limit on the \f$y\f$-axis.
	 * @param opt Draw options.
	 * @param logScale If this argument contains an `'x'`, the \f$x\f$-scale will be set to log scale (same for `'y'` and `'z'`).
	 */
	TH2F* BOSSRootFile::DrawBranches(const char* treeName, const char* branchX, const char* branchY, const Int_t nBinx, const double x1, const double x2, const Int_t nBiny, const double y1, const double y2, Option_t* opt, const TString &logScale)
	{
		return fTrees.at(treeName).DrawBranches(branchX, branchY, nBinx, x1, x2, nBiny, y1, y2, true, opt, logScale);
	}


	/**
	 * @brief Check if file is loaded.
	 */
	bool BOSSRootFile::IsZombie()
	{
		return fFile.IsZombie();
	}


	/**
	 * @brief Draw the distributions of all branches available in the ROOT file.
	 * 
	 * @param treeName Name of the `TTree` that you are looking for.
	 * @param opt Draw options.
	 * @param logScale If this argument contains an `'x'`, the \f$x\f$-scale will be set to log scale (same for `'y'` and `'z'`).
	 */
	void BOSSRootFile::DrawAndSaveAllBranches(const char* treeName, Option_t* opt, const TString &logScale)
	{
		fTrees.at(treeName).DrawAndSaveAllBranches(opt, logScale);
	}


	/**
	 * @brief Draw the distributions of all branches available in the ROOT file.
	 * 
	 * @param treeName Name of the `TTree` that you are looking for.
	 * @param branchNames Name of the branch names that you want to plot. See https://root.cern.ch/doc/master/classTTree.html#a8a2b55624f48451d7ab0fc3c70bfe8d7 for the syntax.
	 * @param opt Draw options.
	 * @param logScale If this argument contains an `'x'`, the \f$x\f$-scale will be set to log scale (same for `'y'` and `'z'`).
	 */
	void BOSSRootFile::DrawBranches(const char* treeName, const char* branchNames, Option_t* opt, const TString &logScale)
	{
		fTrees.at(treeName).DrawBranches(branchNames, true, opt, logScale);
	}

	/**
	 * @brief Print information about all trees in the `TFile`.
	 */
	void BOSSRootFile::Print()
	{
		// * Check if class has been constructed *
		if(!fFile.IsOpen()) {
			std::cout << std::endl << "File not loaded" << std::endl;
			return;
		}
		// * If so, print all 
		std::cout << std::endl << "File name: \"" << fFile.GetName() << "\"" << std::endl;
		if(fTrees.size()) {
			std::cout << "  contains " << fTrees.size() << " TTrees:" << std::endl;
			std::unordered_map<std::string, TChainLoader>::iterator it = fTrees.begin();
			for(; it != fTrees.end(); ++it) {
				TTree* tree = it->second.Get();
				if(tree) std::cout << "    \"" <<
					tree->GetName() << "\"\t\"" <<
					tree->GetTitle() << "\"\t" <<
					tree->GetEntries() << " entries" << std::endl;
			}
		} else {
			std::cout << "  does not contain any TTrees" << std::endl;
		}
		std::cout << std::endl;
		std::cout << "  Output of fFile.ls():" << std::endl;
		std::cout << "  ---------------------" << std::endl;
		fFile.ls();
		std::cout << std::endl;
	}


	/**
	 * @brief Print information about a certan tree.
	 * @details This function loops over the `unordered_map` of file names and over the `unordered_map` of trees and prints its name and number of events. For each tree, information about its branches is also printed.
	 * @param nameOfTree
	 * @param opt
	 */
	void BOSSRootFile::Print(const char* nameOfTree, Option_t *opt)
	{
		TTree* tree = FindTree(nameOfTree);
		if(tree) {
			tree->Print(opt);
			std::cout << "------------------------------------" << std::endl;
			std::cout << "Total number of events in tree \"" << tree->GetName() << "\": " << std::scientific << tree->GetEntries() << std::endl;
		}
		std::cout << std::endl;
	}


	/**
	 * @brief Method that prints the number of entries of each `TTree` in the ROOT file. This allows you to get an idea of the cut flow of the original macro. (Of course, have a look at your original source code `.cxx` to see what these numbers mean.)
	 */
	void BOSSRootFile::PrintCutFlow()
	{
		/// 1. Write number of entries per `TTree`.
			auto width = std::ceil(std::log10(GetLargestEntries()));
			width += 2;
			width += width/3;
			auto list = CreateOrderedMap();
			std::cout << std::endl << "CUT FLOW FOR " << fTrees.size() << " TREES" << std::endl;
			for(auto it : list) {
				std::cout
					<< std::right << std::setw(width) << CommonFunctions::Print::CommaFormattedString(it->GetEntries()) << "  "
					<< std::left  << "\"" << it->Get()->GetName() << "\"" << std::endl;
			}
			std::cout << std::endl;
		/// 2. If there is a `TTree` called `"_cutvalues"`, print these values and names as well.
			auto key = fTrees.find("_cutvalues");
			if(key == fTrees.end()) return;
			if(!key->second.GetEntries()) return;
			key->second.Get()->GetEntry(0); // get first entry of `TTree`
			std::cout << "CUT PARAMTERS" << std::endl;
			std::map<std::string, Double_t> tempMap; // temp *sorted* `map`
			int length = 0;
			for(auto it : key->second.Get_D()) {
				tempMap[it.first] = it.second;
				if(it.first.length() > length) length = it.first.length();
			}
			length += 4;
			for(auto it : tempMap) {
				std::cout
					<< std::setw(length) << std::right << it.first << ": "
					<< it.second << std::endl;
			}
			std::cout << std::endl;
	}


	/**
	 * @brief Draw the distributions of all branches available in the ROOT file.
	 * @param opt Draw options.
	 */
	void BOSSRootFile::QuickDrawAndSaveAll(Option_t* opt)
	{
		for(auto it = fTrees.begin(); it != fTrees.end(); ++it) it->second.DrawAndSaveAllBranches(opt);
	}

// * =============================== * //
// * ------- PRIVATE METHODS ------- * //
// * =============================== * //

	/**
	 * @brief Attempt to open `TFile`.
	 */
	bool BOSSRootFile::OpenFile(const char* filename)
	{
		// * Close file if open *
		CloseFile();
		// * Attempt to open file *
		if(fFile.IsZombie()) {
			std::cout << "ERROR: File \"" << filename << "\" is zombie" << std::endl;
			return false;
		}
		return true; // if successful
	}


	/**
	 * @brief Create a `list` that is ordered by the number of entries in the `TTree`.
	 */
	std::list<TChainLoader*> BOSSRootFile::CreateOrderedMap()
	{
		// * Create list of pointers to `TChainLoader` * //
		std::list<TChainLoader*> outputList;
		for(auto it = fTrees.begin(); it != fTrees.end(); ++it) {
			TString name(it->second.Get()->GetName());
			if(!name.EqualTo("_cutvalues")) outputList.push_back(&(it->second));
		}
		// * Sort resulting list based on number of entries * //
		outputList.sort([](TChainLoader* const & a, TChainLoader* const & b)
		{
			std::string nameA = a->Get()->GetName();
			std::string nameB = b->Get()->GetName();
			return a->GetEntries() != b->GetEntries() ?
				a->GetEntries() > b->GetEntries() :
				nameA < nameB;
		});
		return outputList;
	}


	/**
	 * @brief Relate an address in the memory to a branch of a `TTree`.
	 *
	 * @tparam T         Template that can be any type (like `double`, `int`, etc.)
	 * @param tree       Pointer to the `TTree` that you want to load a branch from.
	 * @param branchName Name of the branch that you are looking.
	 * @param address    Type (address) that you want to set.
	 */
	template<class T>
	int BOSSRootFile::SetBranchAddress(TTree* tree, const char* branchName, T& address)
	{
		if(!tree) {
			std::cout << "ERROR: TTree* is a null pointer" << std::endl;
			// std::terminate(); // use this if you want the class construction to be strict
		}
		int result = tree->SetBranchAddress(branchName, &address);
		if(result < 0) {
			std::cout << "WARNING: Attempt to load \"" << branchName << "\" from TTree \"" << tree->GetName() << "\" resulted in error code " << result << std::endl;
			// std::terminate(); // use this if you want the class construction to be strict
		}
		return result;
	}


	/**
	 * @brief Encapsulation of the default destructor.
	 */
	void BOSSRootFile::Destruct()
	{
		CloseFile();  // close file
		Initialize(); // set pointers to null
	}


	/**
	 * @brief Initialize (null)pointers and clear the `unordered_map` of `TTree`s.
	 */
	void BOSSRootFile::Initialize()
	{
		fTrees.clear();
	}


	/**
	 * @brief If the ROOT `TFile` could be successfully loaded, this method will generate a `unordered_map` of pointers to all `TTree`s in the main folder of the ROOT file.
	 */
	void BOSSRootFile::LoadTrees(bool print)
	{
		// * Go through keys in the file and add to map of TTrees *
		TIter next(fFile.GetListOfKeys());
		TObject *obj  = nullptr;
		TKey    *key  = nullptr;
		TTree   *tree = nullptr;
		while((obj = next())) {
			if((key = dynamic_cast<TKey*>(obj))) {
				if((tree = dynamic_cast<TTree*>(key->ReadObj()))) {
					fTrees.emplace(tree->GetName(), TChainLoader(tree, print));
				}
			}
		}
		// * Output *
		std::cout
			<< "Created a map of " << fTrees.size() << " TTrees based on file \"" << fFile.GetName() << "\"" << std::endl;

		// * Error output *
		std::cout << "Loaded " << fTrees.size() << " TTrees from file \"" << fFile.GetName() << "\"" << std::endl;
	}



#endif