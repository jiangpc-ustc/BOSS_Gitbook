  if(nevtgen>0) goto mycontinue;

  //Print run data
  cout << "-------------------------------------------------------------" << endl;
  if(flags_.ph0==0)
  {
    if(flags_.pion==0)
      cout << "PHOKHARA 9.1 : e^+ e^- -> mu^+ mu^- gamma" << endl;
    else if(flags_.pion==1)
      cout << "PHOKHARA 9.1: e^+ e^- -> pi^+ pi^- gamma" << endl;
    else if(flags_.pion==2)
      cout << "PHOKHARA 9.1: e^+ e^- -> pi^+ pi^- 2pi^0 gamma" << endl;
    else if(flags_.pion==3)
      cout << "PHOKHARA 9.1: e^+ e^- -> 2pi^+ 2pi^- gamma" << endl;
    else if(flags_.pion==4)
      cout << "PHOKHARA 9.1: e^+ e^- -> p pbar gamma" << endl;
    else if(flags_.pion==5)
      cout << "PHOKHARA 9.1: e^+ e^- -> n nbar gamma" << endl;
    else if(flags_.pion==6)
      cout << "PHOKHARA 9.1: e^+ e^- -> K^+ K^- gamma" << endl;
    else if(flags_.pion==7)
      cout << "PHOKHARA 9.1: e^+ e^- -> K_0 K_0bar gamma" << endl;
    else if(flags_.pion==8)
      cout << "PHOKHARA 9.1: e^+ e^- -> pi^+ pi^- pi^0 gamma" << endl;
    else if(flags_.pion==9)
      cout << "PHOKHARA 9.1 : e^+ e^- -> Lambda (-> pi^- p) Lambda bar (-> pi^+ pbar) gamma" << endl;
    else if(flags_.pion==10)
      cout << "PHOKHARA 9.1: e^+ e^- -> pi^+ pi^- eta gamma" << endl;
    else
      cout << "PHOKHARA 9.1: not yet implemented" << endl;
  }
  else
  {
    if(flags_.pion==0)
      cout << "PHOKHARA 9.1 : e^+ e^- -> mu^+ mu^-" << endl;
    else if(flags_.pion==1)
      cout << "PHOKHARA 9.1: e^+ e^- -> pi^+ pi^-" << endl;
    else if(flags_.pion==2)
      cout << "PHOKHARA 9.1: e^+ e^- -> pi^+ pi^- 2pi^0" << endl;
    else if(flags_.pion==3)
      cout << "PHOKHARA 9.1: e^+ e^- -> 2pi^+ 2pi^-" << endl;
    else if(flags_.pion==4)
      cout << "PHOKHARA 9.1: e^+ e^- -> p pbar" << endl;
    else if(flags_.pion==5)
      cout << "PHOKHARA 9.1: e^+ e^- -> n nbar" << endl;
    else if(flags_.pion==6)
      cout << "PHOKHARA 9.1: e^+ e^- -> K^+ K^-" << endl;
    else if(flags_.pion==7)
      cout << "PHOKHARA 9.1: e^+ e^- -> K_0 K_0bar" << endl;
    else if(flags_.pion==8)
      cout << "PHOKHARA 9.1: e^+ e^- -> pi^+ pi^- pi^0" << endl;
    else if(flags_.pion==9)
      cout << "PHOKHARA 9.1 : e^+ e^- -> Lambda (-> pi^- p) Lambda bar (-> pi^+ pbar)" << endl;
    else if(flags_.pion==10)
      cout << "PHOKHARA 9.1: e^+ e^- -> pi^+ pi^- eta" << endl;
    else
      cout << "PHOKHARA 9.1: not yet implemented" << endl;
  }
  cout << "--------------------------------------------------------------" << endl;

  cout << "CM total energy = " << sqrt(ctes_.Sp) << " GeV" << endl;
  if(flags_.ph0==0) //Scan mode not enabled?
  {
    if((0.5*cuts_.gmin/ctes_.ebeam) < 0.0098)
    {
      cout << "Minimal missing energy set to small" << endl;
      if(!m_sloppy) abort();
    }
    cout << "Minimal tagged photon energy  = " << cuts_.gmin << " GeV"  << endl;
    cout << "Angular cuts on tagged photon = " << cuts_.phot1cut << "," << cuts_.phot2cut << endl;
  }

  //Print angular cuts
  if(flags_.pion==0)
    cout << "Angular cuts on muons             = " << cuts_.pi1cut << "," << cuts_.pi2cut << endl;
  else if(flags_.pion==4)
    cout << "Angular cuts on protons           = " << cuts_.pi1cut << "," << cuts_.pi2cut << endl;
  else if(flags_.pion==5)
    cout << "Angular cuts on neutrons          = " << cuts_.pi1cut << "," << cuts_.pi2cut << endl;
  else if((flags_.pion==6) || (flags_.pion==7))
    cout << "Angular cuts on kaons             = " << cuts_.pi1cut << "," << cuts_.pi2cut << endl;
  else if(flags_.pion==9)
    cout << "Angular cuts on pions and protons = " << cuts_.pi1cut << "," << cuts_.pi2cut << endl;
  else if(flags_.pion==10)
    cout << "Angular cuts on pions and eta     = " << cuts_.pi1cut << "," << cuts_.pi2cut << endl;
  else
    cout << "Angular cuts on pions             = " << cuts_.pi1cut << "," << cuts_.pi2cut << endl;

  if(flags_.ph0==0) //Scan mode not enabled?
  {
    if(flags_.pion==0)
      cout << "Min. muons-tagged photon inv.mass^2     = " << cuts_.q2min << " GeV^2" << endl;
    else if(flags_.pion==4)
      cout << "Min. protons-tagged photon inv.mass^2   = " << cuts_.q2min << " GeV^2" << endl;
    else if(flags_.pion==5)
      cout << "Min. neutrons-tagged photon inv.mass^2  = " << cuts_.q2min << " GeV^2" << endl;
    else if((flags_.pion==6) || (flags_.pion==7))
      cout << "Min. kaons-tagged photon inv.mass^2     = " << cuts_.q2min << " GeV^2" << endl;
    else if(flags_.pion==9)
      cout << "Min. lambdas-tagged photon inv.mass^2   = " << cuts_.q2min << " GeV^2" << endl;
    else if(flags_.pion==10)
      cout << "Min. pi-pi-eta-tagged photon inv.mass^2 = " << cuts_.q2min << " GeV^2" << endl;
    else
      cout << "Min. pions-tagged photon inv.mass^2     = " << cuts_.q2min << " GeV^2" << endl;
  }

  //Set cuts
  cos1min = cos(cuts_.phot2cut*ctes_.pi/180.0); //Photon1 angle cuts in lab rest frame
  cos1max = cos(cuts_.phot1cut*ctes_.pi/180.0); //Photon1 angle cuts in lab rest frame
  cos2min = -1.0; //Photon2 angle limits
  cos2max =  1.0; //Photon2 angle limits
  cos3min = -1.0; //Hadrons/muons angle limits in their rest frame
  cos3max =  1.0; //Hadrons/muons angle limits in their rest frame

  if(flags_.pion==0)                   //Virtual photon energy cut
    qqmin = 4.0*ctes_.mmu*ctes_.mmu;
  else if(flags_.pion==1)
    qqmin = 4.0*ctes_.mpi*ctes_.mpi;
  else if(flags_.pion==2)
    qqmin = 4.0*(ctes_.mpi+ctes_.mpi0)*(ctes_.mpi+ctes_.mpi0);
  else if(flags_.pion==3)
    qqmin = 16.0*ctes_.mpi*ctes_.mpi;
  else if(flags_.pion==4)
    qqmin = 4.0*ctes_.mp*ctes_.mp;
  else if(flags_.pion==5)
    qqmin = 4.0*ctes_.mnt*ctes_.mnt;
  else if(flags_.pion==6)
    qqmin = 4.0*ctes_.mKp*ctes_.mKp;
  else if(flags_.pion==7)
    qqmin = 4.0*ctes_.mKn*ctes_.mKn;
  else if(flags_.pion==8)
    qqmin = (2.0*ctes_.mpi+ctes_.mpi0)*(2.0*ctes_.mpi+ctes_.mpi0);
  else if(flags_.pion==9)
    qqmin = 4.0*ctes_.mlamb*ctes_.mlamb;
  else if(flags_.pion==10)
    qqmin = (2.0*ctes_.mpi+ctes_.meta)*(2.0*ctes_.mpi+ctes_.meta);
  qqmax = ctes_.Sp-2.0*sqrt(ctes_.Sp)*cuts_.gmin; //If only one photon

  //Check upper bound for maximum q^2 cut in ISR mode
  if((cuts_.q2_max_c < qqmax) && (flags_.ph0==0))
    qqmax = cuts_.q2_max_c; //External cut for maximum q^2

  //Check lower bound for minimum q^2 cut
  if(flags_.ph0==0) //In ISR mode
  {
    if((cuts_.q2_min_c > qqmin) && (cuts_.q2_min_c < (ctes_.Sp*(1.0-2.0*(cuts_.gmin/sqrt(ctes_.Sp)+cuts_.w)))))
      qqmin = cuts_.q2_min_c; //External cut for minimum q^2
    else
    {
      cout << " Q^2_min out of range" << endl;
      cout << " Q^2_min changed by PHOKHARA to = " << qqmin << " GeV^2" << endl;
    }
  }
  else if((flags_.ph0==1) || (flags_.ph0==-1)) //In Scan mode
  {
    if((cuts_.q2_min_c > qqmin) && (cuts_.q2_min_c < (ctes_.Sp-2.0*sqrt(ctes_.Sp)*cuts_.gmin)))
      qqmin = cuts_.q2_min_c; //External cut for minimum q^2
    else
    {
      cout << " Q^2_min out of range" << endl;
      cout << " Q^2_min changed by PHOKHARA to = " << qqmin << " GeV^2" << endl;
    }
  }

  //Check lower and upper q^2 cut bounds for consistency
  if(qqmax<=qqmin)
  {
    cout << " Q^2_max too small" << endl;
    cout << " Q^2_max = " << qqmax << endl;
    cout << " Q^2_min = " << qqmin << endl;
    if(!m_sloppy) abort();
  }

  //Print invariant mass range cuts
  if(flags_.ph0==0) //In ISR mode
  {
    if(flags_.pion==0)
    {
      cout << "Minimal muon-pair invariant mass^2    = "<< qqmin << " GeV^2" << endl;
      cout << "Maximal muon-pair invariant mass^2    = "<< qqmax << " GeV^2" << endl;
    }
    else if(flags_.pion==1)
    {
      cout << "Minimal pion-pair invariant mass^2    = "<< qqmin << " GeV^2" << endl;
      cout << "Maximal pion-pair invariant mass^2    = "<< qqmax << " GeV^2" << endl;
    }
    else if(flags_.pion==4)
    {
      cout << "Minimal proton-pair invariant mass^2  = "<< qqmin << " GeV^2" << endl;
      cout << "Maximal proton-pair invariant mass^2  = "<< qqmax << " GeV^2" << endl;
    }
    else if(flags_.pion==5)
    {
      cout << "Minimal neutron-pair invariant mass^2 = "<< qqmin << " GeV^2" << endl;
      cout << "Maximal neutron-pair invariant mass^2 = "<< qqmax << " GeV^2" << endl;
    }
    else if((flags_.pion==6) || (flags_.pion==7))
    {
      cout << "Minimal kaon-pair invariant mass^2    = "<< qqmin << " GeV^2" << endl;
      cout << "Maximal kaon-pair invariant mass^2    = "<< qqmax << " GeV^2" << endl;
    }
    else if(flags_.pion==8)
    {
      cout << "Minimal three-pion invariant mass^2   = "<< qqmin << " GeV^2" << endl;
      cout << "Maximal three-pion invariant mass^2   = "<< qqmax << " GeV^2" << endl;
    }
    else if(flags_.pion==9)
    {
      cout << "Minimal lambda-pair invariant mass^2  = "<< qqmin << " GeV^2" << endl;
      cout << "Maximal lambda-pair invariant mass^2  = "<< qqmax << " GeV^2" << endl;
    }
    else if(flags_.pion==10)
    {
      cout << "Minimal pi-pi-eta invariant mass^2    = "<< qqmin << " GeV^2" << endl;
      cout << "Maximal pi-pi-eta invariant mass^2    = "<< qqmax << " GeV^2" << endl;
    }
    else
    {
      cout << "Minimal four-pion invariant mass^2    = "<< qqmin << " GeV^2" << endl;
      cout << "Maximal four-pion invariant mass^2    = "<< qqmax << " GeV^2" << endl;
    }
  }
  else if((flags_.ph0==1) || (flags_.ph0==-1)) //In Scan mode
  {
    if(flags_.pion==0)
    {
      cout << "Minimal muon-pair invariant mass^2    = "<< qqmin << " GeV^2" << endl;
      cout << "Maximal muon-pair invariant mass^2    = "<< ctes_.Sp << " GeV^2" << endl;
    }
    else if(flags_.pion==1)
    {
      cout << "Minimal pion-pair invariant mass^2    = "<< qqmin << " GeV^2" << endl;
      cout << "Maximal pion-pair invariant mass^2    = "<< ctes_.Sp << " GeV^2" << endl;
    }
    else if(flags_.pion==4)
    {
      cout << "Minimal proton-pair invariant mass^2  = "<< qqmin << " GeV^2" << endl;
      cout << "Maximal proton-pair invariant mass^2  = "<< ctes_.Sp << " GeV^2" << endl;
    }
    else if(flags_.pion==5)
    {
      cout << "Minimal neutron-pair invariant mass^2 = "<< qqmin << " GeV^2" << endl;
      cout << "Maximal neutron-pair invariant mass^2 = "<< ctes_.Sp << " GeV^2" << endl;
    }
    else if((flags_.pion==6) || (flags_.pion==7))
    {
      cout << "Minimal kaon-pair invariant mass^2    = "<< qqmin << " GeV^2" << endl;
      cout << "Maximal kaon-pair invariant mass^2    = "<< ctes_.Sp << " GeV^2" << endl;
    }
    else if(flags_.pion==8)
    {
      cout << "Minimal three-pion invariant mass^2   = "<< qqmin << " GeV^2" << endl;
      cout << "Maximal three-pion invariant mass^2   = "<< ctes_.Sp << " GeV^2" << endl;
    }
    else if(flags_.pion==9)
    {
      cout << "Minimal lambda-pair invariant mass^2  = "<< qqmin << " GeV^2" << endl;
      cout << "Maximal lambda-pair invariant mass^2  = "<< ctes_.Sp << " GeV^2" << endl;
    }
    else if(flags_.pion==10)
    {
      cout << "Minimal pi-pi-eta invariant mass^2    = "<< qqmin << " GeV^2" << endl;
      cout << "Maximal pi-pi-eta invariant mass^2    = "<< ctes_.Sp << " GeV^2" << endl;
    }
    else
    {
      cout << "Minimal four-pion invariant mass^2    = "<< qqmin << " GeV^2" << endl;
      cout << "Maximal four-pion invariant mass^2    = "<< ctes_.Sp << " GeV^2" << endl;
    }
  }

  //Handle Born/NLO switches for ISR and Scan modes
  if(flags_.ph0==-1) //Scan mode, Born only
    cout << "Born" << endl;
  else if(flags_.ph0==0) //ISR mode
  {
     if(flags_.nlo==0)
     {
       cout << "Born" << endl;
       if(flags_.fsrnlo!=0)
       {
         cout << "Wrong FSRNLO switch: only FSRNLO = 0 allowed for Born" << endl;
         if(!m_sloppy) abort();
       }
     }
  }
  else //Scan mode
  {
    if(flags_.nlo==0)
      cout << "ISR NLO" << endl;
    else if(flags_.nlo==1)
      cout << "ISR NNLO" << endl;
    else
    {
      cout << "Wrong NLO switch" << endl;
      if(!m_sloppy) abort();
    }
  }

  //Handle NLO for Lambda Lambdabar in ISR and Scan modes
  if((flags_.pion==9) && (flags_.nlo!=0))
  {
    cout << "Wrong NLO switch";
    if(flags_.ph0==1)  cout << ": only NLO allowed for Lambdas" << endl;
    if(flags_.ph0==0)  cout << ": only Born allowed for Lambdas" << endl;
    cout << "If you feel that you need better precision, please contact the authors" << endl;
    if(!m_sloppy) abort();
  }

  //In Scan mode, handle soft photon cuts and FSR Coulomb factor
  if(flags_.ph0==1)
  {
    if(flags_.nlo==0) cout << "NLO:  soft photon cutoff w = " << cuts_.w << endl;
    if(flags_.nlo==1) cout << "NNLO: soft photon cutoff w = " << cuts_.w << endl;
    if(flags_.fsr!=0) cout << "Coulomb factor included" << endl;
  }

  //In ISR mode, first handle mu+mu-...
  if((flags_.ph0==0) || (flags_.pion==0))
  {
    if(flags_.nlo==0)
    {
      if(flags_.fsrnlo!=0)
      {
        cout << "Wrong combination of FSR, FSRNLO switches" << endl;
        if(!m_sloppy) abort();
      }
      else
      {
        if(flags_.fsr==0)
          cout << "ISR only" << endl;
        else if(flags_.fsr==1)
          cout << "ISR+FSR" << endl;
        else if(flags_.fsr==2)
          cout << "ISR+INT+FSR" << endl;
        else
        {
          cout << "Wrong FSR switch" << endl;
          if(!m_sloppy) abort();
        }
      }
    }
    else if(flags_.nlo==1)
    {
      if(flags_.fsrnlo==1)
      {
        if(flags_.fsr==2)
          cout << "ISR+INT+FSR" << endl;
        else
        {
          cout << "Wrong switches" << endl;
          cout << "Combinations for mu+mu- NLO mode:" << endl;
          cout << "NLO = 1 then" << endl;
          cout << "FSR = 0, IFSNLO = 0" << endl;
          cout << "FSR = 2, IFSNLO = 1" << endl;
          if(!m_sloppy) abort();
        }
      }
    }
  }

  //...and then other final states in ISR mode
  if(flags_.ph0==0)
  {
    //... handle soft photon cuts, ...
    if(flags_.nlo==1) cout << "NLO:  soft photon cutoff w = " << cuts_.w << endl;

    //... and check various FSR and FSRNLO combinations for validity in implemented modes
    if((flags_.pion==1) || (flags_.pion==4)|| (flags_.pion==6))
    {
      if(((flags_.fsr==1) || (flags_.fsr==2)) && (flags_.fsrnlo==0))
      {
        ; //NOP
      }
      else if((flags_.fsr==1) && (flags_.fsrnlo==1))
      {
        ; //NOP
      }
      else if((flags_.fsr==0) && (flags_.fsrnlo==0))
      {
        ; //NOP
      }
      else
      {
        cout << "Wrong combination of FSR, FSRNLO switches" << endl;
        if(!m_sloppy) abort();
      }

      //Check FSR, ISR flags
      if(flags_.fsr==0)
        cout << "ISR only" << endl;
      else if(flags_.fsr==1)
        cout << "ISR+FSR" << endl;
      else if(flags_.fsr==2)
      {
        if(flags_.nlo==0)
          cout << "ISR+INT+FSR" << endl;
        else
        {
          cout << "Wrong FSR switch: interference is included only for NLO = 0" << endl;
          if(!m_sloppy) abort();
        }
      }
      else
      {
        cout << "Wrong FSR switch" << flags_.fsr << endl;
        if(!m_sloppy) abort();
      }

      if(flags_.fsrnlo==1)
        cout << "IFSNLO included" << endl;
    }
    else //in some modes, FSR is not available
    {
      if((flags_.fsr==0) && (flags_.fsrnlo==0))
        cout << "ISR only" << endl;
      else if(flags_.pion==0)
        ; //NOP
      else
      {
        cout << "FSR is implemented only for pi+pi-, mu+mu- and K+K- modes" << endl;
        if(!m_sloppy) abort();
      }
    }
  }

  //Handle vacuum polarisation
  if(flags_.ivac==0)
    cout << "Vacuum polarization is NOT included" << endl;
  else if(flags_.ivac==1)
    cout << "Vacuum polarization by Fred Jegerlehner (http://www-com.physik.hu-berlin.de/fjeger/alphaQEDn.uu)" << endl;
  else if(flags_.ivac==2)
    cout << "Vacuum polarization by Daisuke Nomura and Thomas Teubner (VP_HLMNT_v1_3nonr)" << endl;
  else
  {
    cout << "Wrong vacuum polarization switch" << endl;
    if(!m_sloppy) abort();
  }

  //Handle pion form factor
  if(flags_.pion==1)
  {
    if(flags_.FF_pion==0)
      cout << "Kuhn-Santamaria pion form factor" << endl;
    else if(flags_.FF_pion==1)
      cout << "Gounaris-Sakurai pion form factor (old)" << endl;
    else if(flags_.FF_pion==2)
      cout << "Gounaris-Sakurai pion form factor (new)" << endl;
    else
    {
      cout << "Wrong pion form factor switch" << endl;
      if(!m_sloppy) abort();
    }

    if(flags_.fsr!=0)
    {
      if(flags_.f0_model==0)
        cout << "f0+f0(600): K+K- model" << endl;
      else if(flags_.f0_model==1)
        cout << "f0+f0(600): \"No structure\" model" << endl;
      else if(flags_.f0_model==2)
        cout << "No f0+f0(600)" << endl;
      else if(flags_.f0_model==3)
        cout << "Only f0, KLOE (Cesare Bini, private communication)" << endl;
      else
      {
        cout << "Wrong f0+f0(600) switch" << endl;
        if(!m_sloppy) abort();
      }
    }
  }

  //Handle Kaon form factor
  if((flags_.pion==6) || (flags_.pion==7))
  {
    if(flags_.FF_kaon==0)
      cout << "Constrained Kaon form factor" << endl;
    else if(flags_.FF_kaon==1)
      cout << "Unconstrained Kaon form factor" << endl;
    else if(flags_.FF_kaon==2)
      cout << "Kuhn-Khodjamirian-Bruch Kaon form factor" << endl;
    else
    {
      cout << "Wrong Kaon form factor switch" << endl;
      if(!m_sloppy) abort();
    }
  }

  //Handle proton form factor
  if((flags_.pion==4) || (flags_.pion==5))
  {
    if(flags_.FF_pp==0)
      cout << "Proton form factor (old)" << endl;
    else if(flags_.FF_pp==1)
      cout << "Proton form factor (new)" << endl;
    else
    {
      cout << "Wrong Proton form factor switch" << endl;
      if(!m_sloppy) abort();
    }
  }

  //Handle J/Psi resonances
  if((flags_.pion==0) || (flags_.pion==1) || (flags_.pion==6) || (flags_.pion==7))
  {
    if(flags_.narr_res==1)
      cout << "Narrow resonance J/Psi included" << endl;
    else if(flags_.narr_res==2)
      cout << "Narrow resonance Psi(2S) included" << endl;
    else if(flags_.narr_res!=0)
    {
      cout << "Wrong NarrowRes switch" << endl;
      if(!m_sloppy) abort();
    }
  }
  cout << "--------------------------------------------------------------" << endl;
mycontinue:
