  if(m_pion<0 || m_pion>10){std::cout<<"mode index for phokhar 0~10, but you give "<<m_pion<<std::endl;abort();}
  EvtId myvpho=EvtPDL::getId("vpho");
  m_E = p->mass();//EvtPDL::getMeanMass(myvpho);
///======== list parameters to be initialized
  m_tagged = 0;
  m_nm = 50000 ; // # of events to determine the maximum
  m_nlo = 1;     // Born(0), NLO(1)
  m_w = 0.0001;  // soft photon cutoff
  m_fsr = 0;     // ISR only(0), ISR+FSR(1), ISR+INT+FSR(2)
  m_fsrnlo = 0 ; // yes(1), no(0)
  m_NarrowRes = 0 ;// none(0) jpsi(1) psip(2)
  m_FF_Kaon = 2 ;  // constrained (0), unconstrained (1), Kuhn-Khodjamirian-Bruch (2)
  m_ivac = 1;      // yes(1), no(0)
  m_FF_Pion = 1 ;  // KS Pionformfactor(0), GS Pionformfactor old(1) and new(2)
  m_f0_model = 0 ; // f0+f0(600): KK model(0), no structure(1),  no f0+f0(600)(2), f0 KLOE(3)
  m_q2min = 0.0;   // minimal  hadrons(muons)-gamma-inv mass squared (GeV^2)
  m_q2_min_c = 0.0447 ; // minimal inv. mass squared of the hadrons(muons)(GeV^2)
  m_q2_max_c = m_E*m_E;    // maximal inv. mass squared of the hadrons(muons)(GeV^2)
  m_gmin = 0.001;       // minimal photon energy/missing energy   (GeV)
  m_phot1cut = 0.0;     // maximal photon angle/missing momentum angle (grad)
  m_phot2cut = 180.0;   // maximal photon angle/missing momentum angle (grad)
  m_pi1cut = 0.0 ;      // minimal hadrons(muons) angle (grad)
  m_pi2cut = 180.0;     // maximal hadrons(muons) angle (grad)

  m_sloppy = false;  //Ignore inconsistencies in parameter configuration (NOT RECOMMENDED)

  if(!(m_pion==0 || m_pion==1 || m_pion==6)){m_fsr = 0;  m_fsrnlo = 0 ;}
  if( m_pion==9 ){m_nlo = 0 ;}
  // --- input parameter initialization -----------
  m_initSeed = 123456789+nevtgen;
  RLXDINIT(1, m_initSeed);
  maxima_.iprint = 0;
  flags_.ph0 =1; //only scan mode  
  flags_.nlo = m_nlo;
  flags_.pion = m_pion;
  flags_.fsr = m_fsr;
  flags_.fsrnlo = m_fsrnlo;
  flags_.ivac = m_ivac;
  flags_.FF_pion  = m_FF_Pion;
  flags_.f0_model = m_f0_model;
  flags_.FF_kaon  = m_FF_Kaon;
  flags_.narr_res = m_NarrowRes;
  flags_.FF_pp=0;

  ctes_.Sp = m_E*m_E;        ;

  cuts_.w = m_w;
  cuts_.q2min = m_q2min;
  cuts_.q2_min_c = m_q2_min_c;
  cuts_.q2_max_c = m_q2_max_c;
  cuts_.gmin = m_gmin;
  cuts_.phot1cut = m_phot1cut;
  cuts_.phot2cut = m_phot2cut;
  cuts_.pi1cut = m_pi1cut;
  cuts_.pi2cut = m_pi2cut;



  INPUT();
  //print out the parameters 
#include "Phokhara_print.txt"
//
 // =================================================
// --- finding the maximum -------------------------
      for(int i = 0; i<3; i++)
        {
          maxima_.Mmax[i] = 1.0;
          maxima_.gross[i] = 0.0;
          maxima_.klein[i] = 0.0;
        }

      if (flags_.nlo == 0)
        maxima_.Mmax[2]=0.0;   // only 1 photon events generated

      if(flags_.ph0==0)  //0-photon events are not generated in ISR mode
        maxima_.Mmax[0] = 0.0;
      if(flags_.ph0==-1) //Only 0 photon events in LO are generated
       {
        maxima_.Mmax[1] = 0.0;
        maxima_.Mmax[2] = 0.0;
       }

      maxima_.tr[0] = 0.0;
      maxima_.tr[1] = 0.0;
      maxima_.tr[2] = 0.0;
      maxima_.count[0] = 0.0;
      maxima_.count[1] = 0.0;
      maxima_.count[2] = 0.0;

      // =================================================
      // --- beginning the MC loop event generation ------
      for(int j = 1; j <= m_nm; j++)
        {
          RANLXDF(Ar_r,1);
          Ar[1] = Ar_r[0];
          if (Ar[1] <= (maxima_.Mmax[0]/(maxima_.Mmax[0]+maxima_.Mmax[1]+maxima_.Mmax[2]))) {
            maxima_.count[0] = maxima_.count[0]+1.0;
            GEN_0PH(1,qqmin,ctes_.Sp,cos3min,cos3max);
          }else 
	    if (Ar[1] <= ( (maxima_.Mmax[0]+maxima_.Mmax[1])/(maxima_.Mmax[0]+maxima_.Mmax[1]+maxima_.Mmax[2]))) {
            maxima_.count[1] = maxima_.count[1]+1.0;
            GEN_1PH(1,qqmin,qqmax,cos1min,cos1max,cos3min,cos3max);
          }
          else {
            maxima_.count[2] = maxima_.count[2]+1.0;
            GEN_2PH(1,qqmin,cos1min,cos1max,cos2min,cos2max,cos3min,cos3max);
          }
        }
      // --- end of the MC loop --------------------------
      // =================================================
      // --- for the second run ---
      maxima_.Mmax[0] = maxima_.gross[0] + 0.1*sqrt(maxima_.gross[0]*maxima_.gross[0]);
      maxima_.Mmax[1] = maxima_.gross[1] + 0.05*sqrt(maxima_.gross[1]*maxima_.gross[1]);
      maxima_.Mmax[2] = maxima_.gross[2] + (0.03+0.02*ctes_.Sp)*sqrt(maxima_.gross[2]*maxima_.gross[2]);
      theMmax0=maxima_.Mmax[0];
      theMmax1=maxima_.Mmax[1]; 
      if((flags_.pion == 1) && (flags_.fsrnlo == 1))
        maxima_.Mmax[1]=maxima_.Mmax[1]*1.5;
      if((flags_.pion == 0) && (flags_.fsrnlo == 1))
        maxima_.Mmax[1]=maxima_.Mmax[1]*1.5;

      if((flags_.pion == 0) && (flags_.fsr == 1) && (flags_.fsrnlo == 0))
        maxima_.Mmax[1]=maxima_.Mmax[1]*1.2;

      if((flags_.pion == 2) || (flags_.pion == 3)){
        maxima_.Mmax[0]=maxima_.Mmax[0]*1.1;
        maxima_.Mmax[1]=maxima_.Mmax[1]*1.1;
      }

      if(flags_.pion == 8){
        maxima_.Mmax[0]=maxima_.Mmax[0]*1.08;
        maxima_.Mmax[1]=maxima_.Mmax[1]*1.1;
      }
// --- end of the second run -----------------------

      maxima_.tr[0] = 0.0;
      maxima_.tr[1] = 0.0;
      maxima_.tr[2] = 0.0;
      maxima_.count[0] = 0.0;
      maxima_.count[1] = 0.0;
      maxima_.count[2] = 0.0;
