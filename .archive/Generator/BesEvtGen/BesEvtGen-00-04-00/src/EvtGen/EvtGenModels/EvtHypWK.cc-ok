//--------------------------------------------------------------------------
//
// Environment:
//      This software is part of the EvtGen package developed jointly
//      for the BaBar and CLEO collaborations.  If you use all or part
//      of it, please give an appropriate acknowledgement.
//
// Copyright Information: See EvtGen/COPYRIGHT
//      Copyright (C) 1998      Caltech, UCSB
//
// Module: EvtVll.cc
//
// Description: The decay of a vector meson to two leptons,
//              or generally, two spin 1/2 particles.
//              E.g., J/psi -> e+ e-
//
// Modification history:
//
//    RYD       January 17, 1997       Module created
//
//------------------------------------------------------------------------
//
#include "EvtGenBase/EvtPatches.hh"
#include <stdlib.h>
#include <iostream>
#include <string>
#include "EvtGenBase/EvtParticle.hh"
#include "EvtGenBase/EvtPDL.hh"
#include "EvtGenBase/EvtGenKine.hh"
#include "EvtGenModels/EvtHypWK.hh"
#include "EvtGenBase/EvtDiracSpinor.hh"
#include "EvtGenBase/EvtReport.hh"
#include "EvtGenBase/EvtVector4C.hh"
#include "EvtGenBase/EvtId.hh"
using std::cout;
using std::endl;

EvtHypWK::~EvtHypWK() {}

void EvtHypWK::getName(std::string& model_name){

  model_name="HypWK";     

}


EvtDecayBase* EvtHypWK::clone(){

  return new EvtHypWK;

}

void EvtHypWK::init(){

  // check that there are 0 arguments
  checkNArg(0);
  checkNDaug(2);

 //  checkSpinParent(EvtSpinType::VECTOR);
   checkSpinParent(EvtSpinType::DIRAC);
  
   checkSpinDaughter(0,EvtSpinType::DIRAC);
   checkSpinDaughter(1,EvtSpinType::SCALAR);
//  checkSpinDaughter(1,EvtSpinType::DIRAC);

}

void EvtHypWK::initProbMax(){

  setProbMax(3.0);

}

void EvtHypWK::decay(EvtParticle *p){

  static EvtId PIP=EvtPDL::getId("pi+");
  static EvtId PIM=EvtPDL::getId("pi-");
  static EvtId PI0=EvtPDL::getId("pi0");
  static EvtId PP=EvtPDL::getId("p+");
  static EvtId PM=EvtPDL::getId("anti-p-");
  static EvtId NP=EvtPDL::getId("n0");
  static EvtId NM=EvtPDL::getId("anti-n0");
 
  static EvtId LP=EvtPDL::getId("Lambda0");
  static EvtId LM=EvtPDL::getId("anti-Lambda0");
  static EvtId SPP=EvtPDL::getId("Sigma+");
  static EvtId SPM=EvtPDL::getId("anti-Sigma-");
  static EvtId SMP=EvtPDL::getId("Sigma-");
  static EvtId SMM=EvtPDL::getId("anti-Sigma+");
  static EvtId XP=EvtPDL::getId("Xi-");
  static EvtId XM=EvtPDL::getId("anti-Xi+");
  static EvtId X0P=EvtPDL::getId("Xi0");
  static EvtId X0M=EvtPDL::getId("anti-Xi0");

 
  p->initializePhaseSpace(getNDaug(),getDaugs());

  EvtParticle *l1, *l2;
  l1 = p->getDaug(0);
  l2 = p->getDaug(1);

  EvtComplex P11,P12,P21,P22,R11,R12,R21,R22;
  
  R11=EvtLeptonPCurrent(l1->spParent(0),p->spParent(0));
  R12=EvtLeptonPCurrent(l1->spParent(0),p->spParent(1));
  R21=EvtLeptonPCurrent(l1->spParent(1),p->spParent(0));
  R22=EvtLeptonPCurrent(l1->spParent(1),p->spParent(1));

  P11=EvtLeptonSCurrent(l1->spParent(0),p->spParent(0));
  P12=EvtLeptonSCurrent(l1->spParent(0),p->spParent(1));
  P21=EvtLeptonSCurrent(l1->spParent(1),p->spParent(0));
  P22=EvtLeptonSCurrent(l1->spParent(1),p->spParent(1));
 
  EvtVector4R pDaug=l1->getP4();
  double p3=pDaug.d3mag();
    

  double M=p->mass();
  double M2=M*M;
  double m=l1->mass();
  double m2=m*m;
  double theta,phi,alpha,beta,ga;   // the following is the 

  EvtId p1,d1,d2;
  p1=p->getId();
  d1=l1->getId();
  d2=l2->getId();

  if((p1==XP)||(p1==XM)){
   alpha=-0.46;phi=-2.1;
   }
  else if((p1==X0P)||(p1==X0M)){ 
   alpha=-0.41;phi=21.0;
   }
  else if((p1==SMP)||(p1==SMM)){
   alpha=-0.07;phi=10.0;
   }
  else if((p1==SPP)||(p1==SPM)){
    if ((d1==PP)||(d1==PM)){
       alpha=-0.98;phi=36.0;
       }
    else if((d1==NP)||(d1==NM)){
       alpha=0.07;phi=167.0;
       }
    else { cout<<"The decay is not discussed."; 
       }
   } 
   else if((p1==LP)||(p1==LM)){
    if (p1==LP){
       alpha=0.64;phi=-6.5;
       }
    else if(p1==LM){
       alpha=-0.64;phi=6.5;
       }
    else { cout<<"The decay is not discussed.";
       }
   }
 else { cout<<"The decay is not discussed.";
       }
//  cout<<"alpha="<<alpha;
 ga=sqrt((1-alpha*alpha)*cos(phi)*cos(phi));
  beta=ga*tan(phi);
  theta=atan(beta/alpha);
  
  EvtComplex cons;
  cons=((m+sqrt(m2+p3*p3))/p3)*sqrt((1-ga)/(1+ga))*exp(EvtComplex(0,theta));

  double norm=1.0/sqrt(2*M2+4*m2-4*m2*m2/M2);

  //vertex(0,0,norm*(P11+cons*R11));
  //vertex(0,1,norm*(P12+cons*R12));
  vertex(1,0,norm*(P21+cons*R21));
  vertex(1,1,norm*(P22+cons*R22));

  return;

}













