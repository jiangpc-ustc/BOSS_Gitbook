#ifndef Physics_Analysis_BOSSRootFile_H
#define Physics_Analysis_BOSSRootFile_H

/**
 * @brief    General container for BOSS analysis output
 * @author   Remco de Boer 雷穆克 (r.e.deboer@students.uu.nl or remco.de.boer@ihep.ac.cn)
 * @date     October 24th, 2018
 * @remark   @b DEVELOPMENTAL
 *
 * @details  The BOSSRootTree class can be used to create several trees from ROOT files generated by the `jopOptions_ana` (analysis) step of the BOSS framework in the most general way, that is, it only loads the ROOT files and creates a list of `TTree`s based on @a (all) trees within those ROOT files. You can create a derived class which maps the list of `TTree`s to a structure with particular names that match the file with which you are working.
 */

// * ========================= * //
// * ------- LIBRARIES ------- * //
// * ========================= * //
	#include "TFile.h"
	#include "TKey.h"
	#include "TList.h"
	#include "TObject.h"
	#include "TString.h"
	#include "TTree.h"
	#include <iostream>
	#include <list>



// * ================================ * //
// * ------- CLASS DEFINITION ------- * //
// * ================================ * //
class BOSSRootFile
{

public:
	// * Constructor and destructors *
	BOSSRootFile();
	BOSSRootFile(const char*);
	~BOSSRootFile();
	void CloseFile();

	// * Information *
	void Print(const char* nameOfTree, Option_t *option = "toponly");
	void Print();
	void PrintTrees(Option_t *option = "");

	// * Getters *
	int GetNumberOfEvents(const char* treeName);
	std::list<TTree*>& GetListOfTTrees();
	TTree* FindTree(const char*);

protected:
	// * Data members *
	TFile             fFile;
	std::list<TTree*> fTrees;

	// * Private methods *
	bool OpenFile(const char*);
	void Initialize();
	void Destruct();
	void LoadTTrees();
	template<class T>
	void SetBranchAddress(TTree* tree, const char* branchName, T& address);

};



// * =========================================== * //
// * ------- CONSTRUCTORS AND DESTRUCTORS ------ * //
// * =========================================== * //

/**
 * @brief Default constructor.
 * @details Currently does nothing as there are no null pointers to set.
 */
BOSSRootFile::BOSSRootFile()
{
	Initialize();
}

/**
 * @brief Constructor that opens a `TFile` and maps its contents.
 */
BOSSRootFile::BOSSRootFile(const char* filename) : fFile(filename)
{
	// * Initialize members (empty them) *
	Initialize();
	// * Load TTrees *
	LoadTTrees();
}

/**
 * @brief Destructor that closes the `TFile` if needed.
 */
BOSSRootFile::~BOSSRootFile()
{
	Destruct();
}


/**
 * @brief Close file
 */
void BOSSRootFile::CloseFile()
{
	fFile.Close();
	fTrees.clear();
}

/**
 * @brief Encapsulation of the default destructor.
 * @details Goes through the list of trees and destroys each of them, then clears the list. Note that just clearing the list would not be sufficient, as its members are pointers.
 */
void BOSSRootFile::Destruct()
{
	CloseFile();  // close file
	Initialize(); // set pointers to null
}


// * ======================= * //
// * ------- GETTERS ------- * //
// * ======================= * //

/**
 * @brief Get this object's list of trees.
 * @return std::list<TTree*>& Reference to the list of trees in this object.
 */
std::list<TTree*>& BOSSRootFile::GetListOfTTrees()
{
	return fTrees;
}

/**
 * @brief Get the number of events in one of the `TTree`s.
 * @param treeName Name of the `TTree` that you are looking for.
 * @return int Tree object that contains the trees. Returns a `nullptr` if this `TTree` does not exist.
 */
int BOSSRootFile::GetNumberOfEvents(const char* treeName)
{
	TTree* tree = FindTree(treeName);
	if(tree) return tree->GetEntries();
	return 0;
}

/**
 * @brief Look for a tree in the files and get its `TTree`.
 * @param treeName Name of the `TTree` that you are looking for.
 * @return TTree* Tree object that contains the trees. Returns a `nullptr` if this `TTree` does not exist.
 */
TTree* BOSSRootFile::FindTree(const char* treeName)
{
	TTree* tree = nullptr;
	// * Loop over list of TTrees *
	std::list<TTree*>::iterator it = fTrees.begin();
	while(it != fTrees.end()) {
		TString name = (*it)->GetName();
		if(name.EqualTo(treeName)) {
			tree = *it;
			break;
		}
		++it;
	}
	// * Pass TTree pointer if the name matches
	if(!tree) {
		std::cout << "ERROR: TTree \"" << treeName << "\" does not exist in file \"" << fFile.GetName() << "\"" << std::endl;
	}
	return tree;
}




// * =========================== * //
// * ------- INFORMATION ------- * //
// * =========================== * //

/**
 * @brief Print information about a certan tree.
 * @details This function loops over the list of file names and over the list of trees and prints its name and number of events. For each tree, information about its branches is also printed.
 * @param nameOfTree
 * @param option
 */
void BOSSRootFile::Print(const char* nameOfTree, Option_t *option)
{
	TTree* tree = FindTree(nameOfTree);
	if(tree) {
		tree->Print(option);
		std::cout << "------------------------------------" << std::endl;
		std::cout << "Total number of events in tree \"" << tree->GetName() << "\": " << std::scientific << tree->GetEntries() << std::endl;
	}
	else std::cout << "Tree \"" << nameOfTree << "\" does not exist" << std::endl;
	std::cout << std::endl;
}

/**
 * @brief Print information about all trees in the `TFile`.
 */
void BOSSRootFile::Print()
{
	// * Check if class has been constructed *
	if(!fFile.IsOpen()) {
		std::cout << std::endl << "File not loaded" << std::endl;
		return;
	}
	// * If so, print all 
	std::cout << std::endl << "File name: \"" << fFile.GetName() << "\"" << std::endl;
	if(fTrees.size()) {
		std::cout << "  contains " << fTrees.size() << " TTrees:" << std::endl;
		std::list<TTree*>::iterator it = fTrees.begin();
		while(it != fTrees.end()) {
			std::cout << "    \"" << (*it)->GetName() << "\"\t\"" << (*it)->GetTitle() << "\"" << std::endl;
			++it;
		}
	} else {
		std::cout << "  does not contain any TTrees" << std::endl;
	}
	std::cout << "  Output of fFile.ls():" << std::endl;
	std::cout << "  ---------------------" << std::endl;
	fFile.ls();
	std::cout << std::endl;
}



// * =============================== * //
// * ------- PRIVATE METHODS ------- * //
// * =============================== * //

/**
 * @brief Initialize (null)pointers and clear the list of `TTree`s.
 */
void BOSSRootFile::Initialize()
{
	fTrees.clear();
}

/**
 * @brief Attempt to open `TFile`.
 */
bool BOSSRootFile::OpenFile(const char* filename)
{
	// * Close file if open *
	CloseFile();
	// * Attempt to open file *
	if(fFile.IsZombie()) {
		std::cout << "ERROR: File \"" << filename << "\" is zombie" << std::endl;
		return false;
	}
	return true; // if successful
}

/**
 * @brief If the ROOT `TFile` could be successfully loaded, this method will generate a list of pointers to all `TTree`s in the main folder of the ROOT file.
 */
void BOSSRootFile::LoadTTrees()
{
	// * Go through keys in the file and add to list of TTrees *
	TIter next(fFile.GetListOfKeys());
	TObject *obj  = nullptr;
	TKey    *key  = nullptr;
	TTree   *tree = nullptr;
	while((obj = next())) {
		if((key = dynamic_cast<TKey*>(obj))) {
			if((tree = dynamic_cast<TTree*>(key->ReadObj()))) {
				// * Add to list of TTrees
				fTrees.push_back(tree);
			}
		}
	}
	// * Output *
	std::cout
		<< "Created a list of " << fTrees.size() << " TTrees based on file \"" << fFile.GetName() << "\"" << std::endl;

	// * Error output *
	std::cout << "Loaded " << fTrees.size() << " TTrees from file \"" << fFile.GetName() << "\"" << std::endl;
}

/**
 * @brief Relate an address in the memory to a branch of a `TTree`.
 *
 * @tparam T         Template that can be any type (like `double`, `int`, etc.)
 * @param tree      Pointer to the `TTree` that you want to load a branch from.
 * @param branchName Name of the branch that you are looking.
 * @param address    Type (address) that you want to set.
 */
template<class T>
void BOSSRootFile::SetBranchAddress(TTree* tree, const char* branchName, T& address)
{
	if(!tree) {
		std::cout << "ERROR: TTree* is a null pointer" << std::endl;
		// std::terminate(); // use this if you want the class construction to be strict
	}
	int result = tree->SetBranchAddress(branchName, &address);
	if(result < 0) {
		std::cout << "WARNING: Attempt to load \"" << branchName << "\" from TTree \"" << tree->GetName() << "\" resulted in error code " << result << std::endl;
		// std::terminate(); // use this if you want the class construction to be strict
	}
}

#endif