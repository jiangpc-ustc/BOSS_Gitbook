#ifndef Physics_Analysis_BOSSRootFile_H
#define Physics_Analysis_BOSSRootFile_H

/**
 * @brief    General container for BOSS analysis output
 * @author   Remco de Boer 雷穆克 (r.e.deboer@students.uu.nl or remco.de.boer@ihep.ac.cn)
 * @date     October 24th, 2018
 * @remark   @b DEVELOPMENTAL
 *
 * @details  The BOSSRootTree class can be used to create several trees from ROOT files generated by the `jopOptions_ana` (analysis) step of the BOSS framework in the most general way, that is, it only loads the ROOT files and creates an `unordered_map` of `TTree`s based on @a (all) trees within those ROOT files. You can create a derived class which maps the map of `TTree`s to a structure with particular names that match the file with which you are working.
 */

// * ========================= * //
// * ------- LIBRARIES ------- * //
// * ========================= * //
	#include "FrameworkSettings.h"
	#include "SimplifiedTree.h"
	#include "TCanvas.h"
	#include "TFile.h"
	#include "TH1D.h"
	#include "TH2D.h"
	#include "TKey.h"
	#include "TList.h"
	#include "TObject.h"
	#include "TString.h"
	#include "TSystem.h"
	#include "TTree.h"
	#include <iostream>
	#include <string>
	#include <utility>
	#include <unordered_map>



// * ================================ * //
// * ------- CLASS DEFINITION ------- * //
// * ================================ * //

	class BOSSRootFile
	{
	public:
		// * CONSTRUCTOR AND DESTRUCTORS * //
		BOSSRootFile();
		BOSSRootFile(const char* filename, bool print = true);
		~BOSSRootFile();
		void CloseFile();

		// * INFORMATION * //
		TH1F* DrawBranches(const char* treeName, const char* branchX, const Int_t nBinx, const double x1, const double x2, Option_t* opt="", const TString &setLogx="");
		TH2F* DrawBranches(const char* treeName, const char* branchX, const char* branchY, const Int_t nBinx, const double x1, const double x2, const Int_t nBiny, const double y1, const double y2, Option_t* opt="", const TString &setLogx="");
		bool IsZombie();
		void DrawAndSaveAllBranches(const char* treeName, Option_t* opt="", const TString &logScale="");
		void DrawBranches(const char* treeName, const char* branchNames, Option_t* opt="", const TString &logScale="");
		void Print();
		void Print(const char* nameOfTree, Option_t *opt = "toponly");
		void PrintTrees(Option_t *opt="");
		void QuickDrawAndSaveAll(Option_t* opt="");

		// * GETTERS * //
		int GetNumberOfEvents(const char* treeName);
		TTree* FindTree(const char* treeName, bool terminate = false);
		SimplifiedTree& operator[](const char* name) { return fTrees.at(name); }

	protected:
		// * DATA MEMBERS * //
		TFile fFile; //!< The `TFile` that has been loaded.
		std::unordered_map<std::string, SimplifiedTree> fTrees; //!< Map of pointers to all `TTree`s in the ROOT file.

		// * PRIVATE METHODS * //
		bool OpenFile(const char*);
		template<class T> int SetBranchAddress(TTree* tree, const char* branchName, T& address);
		void Destruct();
		void Initialize();
		void LoadTrees(bool print = true);

	};



// * =========================================== * //
// * ------- CONSTRUCTORS AND DESTRUCTORS ------ * //
// * =========================================== * //

	/**
	 * @brief Default constructor.
	 * @details Currently does nothing as there are no null pointers to set.
	 */
	BOSSRootFile::BOSSRootFile()
	{
		Initialize();
	}

	/**
	 * @brief Constructor that opens a `TFile` and unordered_maps its contents.
	 */
	BOSSRootFile::BOSSRootFile(const char* filename, bool print) : fFile(filename)
	{
		// * Initialize members (empty them) *
		Initialize();
		// * Load TTrees *
		LoadTrees(print);
	}

	/**
	 * @brief Destructor that closes the `TFile` if needed.
	 */
	BOSSRootFile::~BOSSRootFile()
	{
		Destruct();
	}


	/**
	 * @brief Close file
	 */
	void BOSSRootFile::CloseFile()
	{
		fFile.Close();
		fTrees.clear();
	}



// * ======================= * //
// * ------- GETTERS ------- * //
// * ======================= * //

	/**
	 * @brief Get the number of events in one of the `TTree`s.
	 * @param treeName Name of the `TTree` that you are looking for.
	 * @return int Tree object that contains the trees. Returns a `nullptr` if this `TTree` does not exist.
	 */
	int BOSSRootFile::GetNumberOfEvents(const char* treeName)
	{
		TTree* tree = FindTree(treeName);
		if(tree) return tree->GetEntries();
		return 0;
	}

	/**
	 * @brief Look for a tree in the files and get its `TTree`.
	 * @param treeName Name of the `TTree` that you are looking for.
	 * @param terminate Set to `true` if you want to terminate the entire programme if the `TTree` is not found. This can be useful if you want to avoid segmenation violations later.
	 * @return TTree* Tree object that contains the trees. Returns a `nullptr` if this `TTree` does not exist.
	 */
	TTree* BOSSRootFile::FindTree(const char* treeName, bool terminate)
	{
		if(terminate) return fTrees.at(treeName).Get();
		else          return fTrees[treeName].Get();
	}



// * =========================== * //
// * ------- INFORMATION ------- * //
// * =========================== * //

	/**
	 * @brief Draw the distributions of all branches available in the ROOT file.
	 * 
	 * @param treeName Name of the `TTree` that you are looking for.
	 * @param branchX Branch that you want to plot. You may use a formula.
	 * @param nBinx Number of bins to use on the \f$x\f$-axis.
	 * @param x1 Lower limit on the \f$x\f$-axis.
	 * @param x2 Upper limit on the \f$x\f$-axis..
	 * @param opt Draw options.
	 * @param logScale If this argument contains an `'x'`, the \f$x\f$-scale will be set to log scale (same for `'y'` and `'z'`).
	 */
	TH1F* BOSSRootFile::DrawBranches(const char* treeName, const char* branchX, const Int_t nBinx, const double x1, const double x2, Option_t* opt, const TString &logScale)
	{
		return fTrees.at(treeName).DrawBranches(branchX, nBinx, x1, x2, true, opt, logScale);
	}


	/**
	 * @brief Draw the distributions of all branches available in the ROOT file.
	 * 
	 * @param treeName Name of the `TTree` that you are looking for.
	 * @param branchX Branch that you want to plot on the \f$x\f$-axis. You may use a formula.
	 * @param branchY Branch that you want to plot on the \f$y\f$-axis. You may use a formula.
	 * @param nBinx Number of bins to use on the \f$x\f$-axis.
	 * @param x1 Lower limit on the \f$x\f$-axis.
	 * @param x2 Upper limit on the \f$x\f$-axis.
	 * @param nBiny Number of bins to use on the \f$y\f$-axis.
	 * @param y1 Lower limit on the \f$y\f$-axis.
	 * @param y2 Upper limit on the \f$y\f$-axis.
	 * @param opt Draw options.
	 * @param logScale If this argument contains an `'x'`, the \f$x\f$-scale will be set to log scale (same for `'y'` and `'z'`).
	 */
	TH2F* BOSSRootFile::DrawBranches(const char* treeName, const char* branchX, const char* branchY, const Int_t nBinx, const double x1, const double x2, const Int_t nBiny, const double y1, const double y2, Option_t* opt, const TString &logScale)
	{
		return fTrees.at(treeName).DrawBranches(branchX, branchY, nBinx, x1, x2, nBiny, y1, y2, true, opt, logScale);
	}


	/**
	 * @brief Check if file is loaded.
	 */
	bool BOSSRootFile::IsZombie()
	{
		return fFile.IsZombie();
	}


	/**
	 * @brief Draw the distributions of all branches available in the ROOT file.
	 * 
	 * @param treeName Name of the `TTree` that you are looking for.
	 * @param opt Draw options.
	 * @param logScale If this argument contains an `'x'`, the \f$x\f$-scale will be set to log scale (same for `'y'` and `'z'`).
	 */
	void BOSSRootFile::DrawAndSaveAllBranches(const char* treeName, Option_t* opt, const TString &logScale)
	{
		fTrees.at(treeName).DrawAndSaveAllBranches(opt, logScale);
	}


	/**
	 * @brief Draw the distributions of all branches available in the ROOT file.
	 * 
	 * @param treeName Name of the `TTree` that you are looking for.
	 * @param branchNames Name of the branch names that you want to plot. See https://root.cern.ch/doc/master/classTTree.html#a8a2b55624f48451d7ab0fc3c70bfe8d7 for the syntax.
	 * @param opt Draw options.
	 * @param logScale If this argument contains an `'x'`, the \f$x\f$-scale will be set to log scale (same for `'y'` and `'z'`).
	 */
	void BOSSRootFile::DrawBranches(const char* treeName, const char* branchNames, Option_t* opt, const TString &logScale)
	{
		fTrees.at(treeName).DrawBranches(branchNames, true, opt, logScale);
	}

	/**
	 * @brief Print information about all trees in the `TFile`.
	 */
	void BOSSRootFile::Print()
	{
		// * Check if class has been constructed *
		if(!fFile.IsOpen()) {
			std::cout << std::endl << "File not loaded" << std::endl;
			return;
		}
		// * If so, print all 
		std::cout << std::endl << "File name: \"" << fFile.GetName() << "\"" << std::endl;
		if(fTrees.size()) {
			std::cout << "  contains " << fTrees.size() << " TTrees:" << std::endl;
			std::unordered_map<std::string, SimplifiedTree>::iterator it = fTrees.begin();
			for(; it != fTrees.end(); ++it) {
				TTree* tree = it->second.Get();
				if(tree) std::cout << "    \"" <<
					tree->GetName() << "\"\t\"" <<
					tree->GetTitle() << "\"\t" <<
					tree->GetEntries() << " entries" << std::endl;
			}
		} else {
			std::cout << "  does not contain any TTrees" << std::endl;
		}
		std::cout << std::endl;
		std::cout << "  Output of fFile.ls():" << std::endl;
		std::cout << "  ---------------------" << std::endl;
		fFile.ls();
		std::cout << std::endl;
	}


	/**
	 * @brief Print information about a certan tree.
	 * @details This function loops over the `unordered_map` of file names and over the `unordered_map` of trees and prints its name and number of events. For each tree, information about its branches is also printed.
	 * @param nameOfTree
	 * @param opt
	 */
	void BOSSRootFile::Print(const char* nameOfTree, Option_t *opt)
	{
		TTree* tree = FindTree(nameOfTree);
		if(tree) {
			tree->Print(opt);
			std::cout << "------------------------------------" << std::endl;
			std::cout << "Total number of events in tree \"" << tree->GetName() << "\": " << std::scientific << tree->GetEntries() << std::endl;
		}
		std::cout << std::endl;
	}


	/**
	 * @brief Draw the distributions of all branches available in the ROOT file.
	 * @param opt Draw options.
	 */
	void BOSSRootFile::QuickDrawAndSaveAll(Option_t* opt)
	{
		std::unordered_map<std::string, SimplifiedTree>::iterator it = fTrees.begin();
		for(; it != fTrees.end(); ++it) it->second.DrawAndSaveAllBranches(opt);
	}



// * =============================== * //
// * ------- PRIVATE METHODS ------- * //
// * =============================== * //

	/**
	 * @brief Attempt to open `TFile`.
	 */
	bool BOSSRootFile::OpenFile(const char* filename)
	{
		// * Close file if open *
		CloseFile();
		// * Attempt to open file *
		if(fFile.IsZombie()) {
			std::cout << "ERROR: File \"" << filename << "\" is zombie" << std::endl;
			return false;
		}
		return true; // if successful
	}


	/**
	 * @brief Relate an address in the memory to a branch of a `TTree`.
	 *
	 * @tparam T         Template that can be any type (like `double`, `int`, etc.)
	 * @param tree       Pointer to the `TTree` that you want to load a branch from.
	 * @param branchName Name of the branch that you are looking.
	 * @param address    Type (address) that you want to set.
	 */
	template<class T>
	int BOSSRootFile::SetBranchAddress(TTree* tree, const char* branchName, T& address)
	{
		if(!tree) {
			std::cout << "ERROR: TTree* is a null pointer" << std::endl;
			// std::terminate(); // use this if you want the class construction to be strict
		}
		int result = tree->SetBranchAddress(branchName, &address);
		if(result < 0) {
			std::cout << "WARNING: Attempt to load \"" << branchName << "\" from TTree \"" << tree->GetName() << "\" resulted in error code " << result << std::endl;
			// std::terminate(); // use this if you want the class construction to be strict
		}
		return result;
	}


	/**
	 * @brief Encapsulation of the default destructor.
	 */
	void BOSSRootFile::Destruct()
	{
		CloseFile();  // close file
		Initialize(); // set pointers to null
	}


	/**
	 * @brief Initialize (null)pointers and clear the `unordered_map` of `TTree`s.
	 */
	void BOSSRootFile::Initialize()
	{
		fTrees.clear();
	}


	/**
	 * @brief If the ROOT `TFile` could be successfully loaded, this method will generate a `unordered_map` of pointers to all `TTree`s in the main folder of the ROOT file.
	 */
	void BOSSRootFile::LoadTrees(bool print)
	{
		// * Go through keys in the file and add to map of TTrees *
		TIter next(fFile.GetListOfKeys());
		TObject *obj  = nullptr;
		TKey    *key  = nullptr;
		TTree   *tree = nullptr;
		while((obj = next())) {
			if((key = dynamic_cast<TKey*>(obj))) {
				if((tree = dynamic_cast<TTree*>(key->ReadObj()))) {
					fTrees.emplace(tree->GetName(), SimplifiedTree(tree, print));
				}
			}
		}
		// * Output *
		std::cout
			<< "Created a map of " << fTrees.size() << " TTrees based on file \"" << fFile.GetName() << "\"" << std::endl;

		// * Error output *
		std::cout << "Loaded " << fTrees.size() << " TTrees from file \"" << fFile.GetName() << "\"" << std::endl;
	}



#endif