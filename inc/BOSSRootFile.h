#ifndef Physics_Analysis_BOSSRootFile_H
#define Physics_Analysis_BOSSRootFile_H

/**
 * @brief    General container for BOSS analysis output
 * @author   Remco de Boer 雷穆克 (r.e.deboer@students.uu.nl or remco.de.boer@ihep.ac.cn)
 * @date     October 24th, 2018
 * @remark   @b DEVELOPMENTAL
 *
 * @details  The BOSSRootTree class can be used to create several trees from ROOT files generated by the `jopOptions_ana` (analysis) step of the BOSS framework in the most general way, that is, it only loads the ROOT files and creates a list of `TTree`s based on @a (all) trees within those ROOT files. You can create a derived class which maps the list of `TTree`s to a structure with particular names that match the file with which you are working.
 */

// * ========================= * //
// * ------- LIBRARIES ------- * //
// * ========================= * //
	#include "FrameworkSettings.h"
	#include "TCanvas.h"
	#include "TFile.h"
	#include "TH1D.h"
	#include "TH2D.h"
	#include "TKey.h"
	#include "TList.h"
	#include "TObject.h"
	#include "TString.h"
	#include "TSystem.h"
	#include "TTree.h"
	#include <iostream>
	#include <list>



// * ================================ * //
// * ------- CLASS DEFINITION ------- * //
// * ================================ * //
class BOSSRootFile
{

public:
	// * Constructor and destructors *
	BOSSRootFile();
	BOSSRootFile(const char*);
	~BOSSRootFile();
	void CloseFile();

	// * Information *
	void Print(const char* nameOfTree, Option_t *option = "toponly");
	void Print();
	void PrintTrees(Option_t *option = "");
	bool IsZombie();
	void PlotDistribution1D(
		TTree* tree, const char* branchName,
		int nBins, double x1, double x2,
		const char* title = "", Option_t* opt = "ep", TString fileName = "");
	void PlotDistribution1D(
		const char* treeName, const char* branchName,
		int nBins, double x1, double x2,
		const char* title = "", Option_t* opt = "ep", TString fileName = "");
	void PlotDistribution2D(
		TTree* tree, const char* branchX, const char* branchY,
		int nBinsX, double x1, double x2,
		int nBinsY, double y1, double y2,
		const char* title = "", Option_t* opt = "colz", bool setLogZ = kFALSE, TString fileName = "");
	void PlotDistribution2D(
		const char* treeName, const char* branchX, const char* branchY,
		int nBinsX, double x1, double x2,
		int nBinsY, double y1, double y2,
		const char* title = "", Option_t* opt = "colz", bool setLogZ = kFALSE, TString fileName = "");

	// * Getters *
	int GetNumberOfEvents(const char* treeName);
	std::list<TTree*>& GetListOfTTrees();
	TTree* FindTree(const char*);

protected:
	// * Data members *
	TFile             fFile;  //!< The `TFile` that has been loaded.
	std::list<TTree*> fTrees; //!< List of pointers to all `TTree`s in the ROOT file

	// * Private methods *
	bool OpenFile(const char*);
	void Initialize();
	void Destruct();
	void LoadTTrees();
	template<class T>
	int SetBranchAddress(TTree* tree, const char* branchName, T& address);

};



// * =========================================== * //
// * ------- CONSTRUCTORS AND DESTRUCTORS ------ * //
// * =========================================== * //

/**
 * @brief Default constructor.
 * @details Currently does nothing as there are no null pointers to set.
 */
BOSSRootFile::BOSSRootFile()
{
	Initialize();
}

/**
 * @brief Constructor that opens a `TFile` and maps its contents.
 */
BOSSRootFile::BOSSRootFile(const char* filename) : fFile(filename)
{
	// * Initialize members (empty them) *
	Initialize();
	// * Load TTrees *
	LoadTTrees();
}

/**
 * @brief Destructor that closes the `TFile` if needed.
 */
BOSSRootFile::~BOSSRootFile()
{
	Destruct();
}


/**
 * @brief Close file
 */
void BOSSRootFile::CloseFile()
{
	fFile.Close();
	fTrees.clear();
}

/**
 * @brief Encapsulation of the default destructor.
 * @details Goes through the list of trees and destroys each of them, then clears the list. Note that just clearing the list would not be sufficient, as its members are pointers.
 */
void BOSSRootFile::Destruct()
{
	CloseFile();  // close file
	Initialize(); // set pointers to null
}


// * ======================= * //
// * ------- GETTERS ------- * //
// * ======================= * //

/**
 * @brief Get this object's list of trees.
 * @return std::list<TTree*>& Reference to the list of trees in this object.
 */
std::list<TTree*>& BOSSRootFile::GetListOfTTrees()
{
	return fTrees;
}

/**
 * @brief Get the number of events in one of the `TTree`s.
 * @param treeName Name of the `TTree` that you are looking for.
 * @return int Tree object that contains the trees. Returns a `nullptr` if this `TTree` does not exist.
 */
int BOSSRootFile::GetNumberOfEvents(const char* treeName)
{
	TTree* tree = FindTree(treeName);
	if(tree) return tree->GetEntries();
	return 0;
}

/**
 * @brief Look for a tree in the files and get its `TTree`.
 * @param treeName Name of the `TTree` that you are looking for.
 * @return TTree* Tree object that contains the trees. Returns a `nullptr` if this `TTree` does not exist.
 */
TTree* BOSSRootFile::FindTree(const char* treeName)
{
	TTree* tree = nullptr;
	// * Loop over list of TTrees *
	std::list<TTree*>::iterator it = fTrees.begin();
	while(it != fTrees.end()) {
		TString name = (*it)->GetName();
		if(name.EqualTo(treeName)) {
			tree = *it;
			break;
		}
		++it;
	}
	// * Pass TTree pointer if the name matches
	if(!tree) {
		std::cout << "ERROR: TTree \"" << treeName << "\" does not exist in file \"" << fFile.GetName() << "\"" << std::endl;
		std::cout << std::endl << "Try:" << std::endl;
		fFile.ls();
		std::terminate();
	}
	return tree;
}




// * =========================== * //
// * ------- INFORMATION ------- * //
// * =========================== * //

/**
 * @brief Print information about a certan tree.
 * @details This function loops over the list of file names and over the list of trees and prints its name and number of events. For each tree, information about its branches is also printed.
 * @param nameOfTree
 * @param option
 */
void BOSSRootFile::Print(const char* nameOfTree, Option_t *option)
{
	TTree* tree = FindTree(nameOfTree);
	if(tree) {
		tree->Print(option);
		std::cout << "------------------------------------" << std::endl;
		std::cout << "Total number of events in tree \"" << tree->GetName() << "\": " << std::scientific << tree->GetEntries() << std::endl;
	}
	else std::cout << "Tree \"" << nameOfTree << "\" does not exist" << std::endl;
	std::cout << std::endl;
}

/**
 * @brief Print information about all trees in the `TFile`.
 */
void BOSSRootFile::Print()
{
	// * Check if class has been constructed *
	if(!fFile.IsOpen()) {
		std::cout << std::endl << "File not loaded" << std::endl;
		return;
	}
	// * If so, print all 
	std::cout << std::endl << "File name: \"" << fFile.GetName() << "\"" << std::endl;
	if(fTrees.size()) {
		std::cout << "  contains " << fTrees.size() << " TTrees:" << std::endl;
		std::list<TTree*>::iterator it = fTrees.begin();
		while(it != fTrees.end()) {
			std::cout << "    \"" << (*it)->GetName() <<
				"\"\t\"" << (*it)->GetTitle() <<
				"\"\t" << (*it)->GetEntries() << " entries" << std::endl;
			++it;
		}
	} else {
		std::cout << "  does not contain any TTrees" << std::endl;
	}
	std::cout << std::endl;
	std::cout << "  Output of fFile.ls():" << std::endl;
	std::cout << "  ---------------------" << std::endl;
	fFile.ls();
	std::cout << std::endl;
}

/**
 * @brief Check if file is loaded.
 */
bool BOSSRootFile::IsZombie()
{
	return fFile.IsZombie();
}

/**
 * @brief Plot a 1D distribution of one of the branches in the file.
 * @todo Move these settings to `FrameworkSettings.h`
 *
 * @param tree       Pointer to the `TTree` that you want to load a branch from.
 * @param branchName Name of the branch that you are looking.
 * @param nBins      The number of bins that you want to have in the resulting histogram.
 * @param x1         Determines left side of the plot range.
 * @param x2         Determines right side of the plot range.
 * @param title      Determines title of the plot.
 * @param opt        Draw options.
 * @param outputFileName Filename of the output file. Extension is set through `CommonFunctions.h`.
 */
void BOSSRootFile::PlotDistribution1D(
	TTree* tree, const char* branchName,
	int nBins, double x1, double x2,
	const char* title, Option_t* opt, TString outputFileName)
{
	// * Check input arguments * //
		if(!tree) {
			std::cout << "ERROR: TTree* is a null pointer" << std::endl;
			return;
		}
		double address;
		int result = SetBranchAddress(tree, branchName, address);
		if(result < 0) {
			std::cout << "ERROR: Attempt to load \"" << branchName << "\" from TTree \"" << tree->GetName() << "\" resulted in error code " << result << std::endl;
			return;
		}
		if(nBins<1) {
			std::cout << "ERROR: Cannot create a histogram with " << nBins << " bins" << std::endl;
			return;
		}
		if(x1 >= x2) {
			std::cout << "ERROR: Value x1=" << x1 << " cannot be more than x2=" << x2 << std::endl;
			return;
		}
	// * Create histogram * //
		TString histTitle(title);
		if(histTitle.EqualTo("")) histTitle = Form("Distribution of \"%s\" in tree \"%s\";;counts", branchName, tree->GetName());
		TH1D hist("hist", histTitle.Data(), nBins, x1, x2);
	// ! Modify histogram styles here ! //
		TCanvas c;
		// hist.SetStats(kFALSE);
	// * Loop over tree to fill histogram * //
		Long64_t nEntries = tree->GetEntries();
		for(Long64_t i = 0; i < nEntries; ++i) {
			tree->GetEntry(i);
			hist.Fill(address);
		}
	// * Draw histogram and save * //
		hist.Draw(opt);
		if(outputFileName.EqualTo("")) {
			const char* outputFolder = Form("%s/%s", Settings::Output::PlotOutputDir.Data(), __BASE_FILE__);
			gSystem->mkdir(outputFolder, kTRUE);
			outputFileName = Form("%s/%s_%s.%s", outputFolder, tree->GetName(), branchName, Settings::Output::Extension);
		}
		c.SaveAs(outputFileName.Data());
		c.Close();
}

/**
 * @brief Plot a 1D distribution of one of the branches in the file.
 * @todo Move these settings to `FrameworkSettings.h`
 *
 * @param treeName   Name of the `TTree` that you want to load a branch from.
 * @param branchName Name of the branch that you are looking.
 * @param nBins      The number of bins that you want to have in the resulting histogram.
 * @param x1         Determines left side of the plot range.
 * @param x2         Determines right side of the plot range.
 * @param title      Determines title of the plot.
 * @param opt        Draw options.
 * @param outputFileName Filename of the output file. Extension is set through `CommonFunctions.h`.
 */
void BOSSRootFile::PlotDistribution1D(
	const char* treeName, const char* branchName,
	int nBins, double x1, double x2,
	const char* title, Option_t* opt, TString outputFileName)
{
	TTree* tree = FindTree(treeName);
	PlotDistribution1D(tree, branchName, nBins, x1, x2, title, opt, outputFileName);
}

/**
 * @brief Plot a 2D distribution of one of the branches in the file.
 * @todo Move these settings to `FrameworkSettings.h`
 *
 * @param tree    Pointer to the `TTree` that you want to load a branch from.
 * @param branchX Name of the X-branch that you are looking.
 * @param branchY Name of the Y-branch that you are looking.
 * @param nBinsX  The number of bins that you want to have in the resulting histogram.
 * @param x1      Determines left side of the plot range.
 * @param x2      Determines right side of the plot range.
 * @param nBinsY  The number of bins that you want to have in the resulting histogram.
 * @param y1      Determines left side of the plot range.
 * @param y2      Determines right side of the plot range.
 * @param title   Determines title of the plot.
 * @param opt     Draw options.
 * @param setLogZ  Use a log scale in the Z-direction.
 * @param outputFileName Filename of the output file. Extension is set through `CommonFunctions.h`.
 */
void BOSSRootFile::PlotDistribution2D(
	TTree* tree, const char* branchX, const char* branchY,
	int nBinsX, double x1, double x2,
	int nBinsY, double y1, double y2,
	const char* title, Option_t* opt, bool setLogZ, TString outputFileName)
{
	// * Check input arguments * //
		if(!tree) {
			std::cout << "ERROR: TTree* is a null pointer" << std::endl;
			return;
		}
		int result;
		double addressX; result = SetBranchAddress(tree, branchX, addressX);
		if(result < 0) {
			std::cout << "ERROR: Attempt to load \"" << branchX << "\" from TTree \"" << tree->GetName() << "\" resulted in error code " << result << std::endl;
			return;
		}
		double addressY; result = SetBranchAddress(tree, branchY, addressY);
		if(result < 0) {
			std::cout << "ERROR: Attempt to load \"" << branchY << "\" from TTree \"" << tree->GetName() << "\" resulted in error code " << result << std::endl;
			return;
		}
		if(nBinsX<1 || nBinsY<1) {
			std::cout << "ERROR: Cannot create a histogram with " << nBinsX << " x " << nBinsY << " bins" << std::endl;
			return;
		}
		if(x1 >= x2) {
			std::cout << "ERROR: Value x1=" << x1 << " cannot be more than x2=" << x2 << std::endl;
			return;
		}
		if(y1 >= y2) {
			std::cout << "ERROR: Value y1=" << y1 << " cannot be more than y2=" << y2 << std::endl;
			return;
		}
	// * Create histogram * //
		TString histTitle(title);
		if(histTitle.EqualTo("")) histTitle = Form("Distribution of \"%s vs %s\" in tree \"%s\";;;counts", branchX, branchY, tree->GetName());
		TH2D hist("hist", histTitle.Data(), nBinsX, x1, x2, nBinsY, y1, y2);
	// ! Modify histogram styles here ! //
		TCanvas c;
		c.SetBatch(kFALSE);
		if(setLogZ) c.SetLogz();
		// hist.SetStats(kFALSE);
	// * Loop over tree to fill histogram * //
		Long64_t nEntries = tree->GetEntries();
		for(Long64_t i = 0; i < nEntries; ++i) {
			tree->GetEntry(i);
			hist.Fill(addressX, addressY);
		}
	// * Draw histogram and save * //
		hist.Draw(opt);
		const char* outputFolder = Form("%s/%s", Settings::Output::PlotOutputDir.Data(), __BASE_FILE__);
		const char* outputFile = Form("%s_%s_%s.%s", tree->GetName(), branchX, branchY, Settings::Output::Extension);
		gSystem->mkdir(outputFolder);
		c.SaveAs(Form("%s/%s", outputFolder, outputFile));
		c.Close();
}

/**
 * @brief Plot a 2D distribution of one of the branches in the file.
 * @todo Move these settings to `FrameworkSettings.h`
 *
 * @param treeName Name of the `TTree` that you want to load a branch from.
 * @param branchX  Name of the X-branch that you are looking.
 * @param branchY  Name of the Y-branch that you are looking.
 * @param nBinsX   The number of bins that you want to have in the resulting histogram.
 * @param x1       Determines left side of the plot range.
 * @param x2       Determines right side of the plot range.
 * @param nBinsY   The number of bins that you want to have in the resulting histogram.
 * @param y1       Determines left side of the plot range.
 * @param y2       Determines right side of the plot range.
 * @param title    Determines title of the plot.
 * @param opt      Draw options.
 * @param setLogZ  Use a log scale in the Z-direction.
 * @param outputFileName Filename of the output file. Extension is set through `CommonFunctions.h`.
 */
void BOSSRootFile::PlotDistribution2D(
	const char* treeName, const char* branchX, const char* branchY,
	int nBinsX, double x1, double x2,
	int nBinsY, double y1, double y2,
	const char* title, Option_t* opt, bool setLogZ, TString outputFileName)
{
	TTree* tree = FindTree(treeName);
	PlotDistribution2D(tree, branchX, branchY, nBinsX, x1, x2, nBinsY, y1, y2, title, opt, setLogZ, outputFileName);
}


// * =============================== * //
// * ------- PRIVATE METHODS ------- * //
// * =============================== * //

/**
 * @brief Initialize (null)pointers and clear the list of `TTree`s.
 */
void BOSSRootFile::Initialize()
{
	fTrees.clear();
}

/**
 * @brief Attempt to open `TFile`.
 */
bool BOSSRootFile::OpenFile(const char* filename)
{
	// * Close file if open *
	CloseFile();
	// * Attempt to open file *
	if(fFile.IsZombie()) {
		std::cout << "ERROR: File \"" << filename << "\" is zombie" << std::endl;
		return false;
	}
	return true; // if successful
}

/**
 * @brief If the ROOT `TFile` could be successfully loaded, this method will generate a list of pointers to all `TTree`s in the main folder of the ROOT file.
 */
void BOSSRootFile::LoadTTrees()
{
	// * Go through keys in the file and add to list of TTrees *
	TIter next(fFile.GetListOfKeys());
	TObject *obj  = nullptr;
	TKey    *key  = nullptr;
	TTree   *tree = nullptr;
	while((obj = next())) {
		if((key = dynamic_cast<TKey*>(obj))) {
			if((tree = dynamic_cast<TTree*>(key->ReadObj()))) {
				// * Add to list of TTrees
				fTrees.push_back(tree);
			}
		}
	}
	// * Output *
	std::cout
		<< "Created a list of " << fTrees.size() << " TTrees based on file \"" << fFile.GetName() << "\"" << std::endl;

	// * Error output *
	std::cout << "Loaded " << fTrees.size() << " TTrees from file \"" << fFile.GetName() << "\"" << std::endl;
}

/**
 * @brief Relate an address in the memory to a branch of a `TTree`.
 *
 * @tparam T         Template that can be any type (like `double`, `int`, etc.)
 * @param tree      Pointer to the `TTree` that you want to load a branch from.
 * @param branchName Name of the branch that you are looking.
 * @param address    Type (address) that you want to set.
 */
template<class T>
int BOSSRootFile::SetBranchAddress(TTree* tree, const char* branchName, T& address)
{
	if(!tree) {
		std::cout << "ERROR: TTree* is a null pointer" << std::endl;
		// std::terminate(); // use this if you want the class construction to be strict
	}
	int result = tree->SetBranchAddress(branchName, &address);
	if(result < 0) {
		std::cout << "WARNING: Attempt to load \"" << branchName << "\" from TTree \"" << tree->GetName() << "\" resulted in error code " << result << std::endl;
		// std::terminate(); // use this if you want the class construction to be strict
	}
	return result;
}

#endif