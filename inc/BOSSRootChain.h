#ifndef Physics_Analysis_BOSSRootChain_H
#define Physics_Analysis_BOSSRootChain_H

/**
 * @brief    General container for BOSS analysis output
 * @author   Remco de Boer 雷穆克 (r.e.deboer@students.uu.nl or remco.de.boer@ihep.ac.cn)
 * @date     October 24th, 2018
 * @remark   @b DEVELOPMENTAL
 *
 * @details  The BOSSRootChain class can be used to create several chains from ROOT files generated by the `jopOptions_ana` (analysis) step of the BOSS framework in the most general way, that is, it only loads the ROOT files and creates a list of `TChain`s based on @a (all) trees within those ROOT files. You can create a derived class which maps the list of `TChain`s to a structure with particular names that match the file with which you are working.
 */


// * ========================= * //
// * ------- LIBRARIES ------- * //
// * ========================= * //
#include <iostream>
#include <list>
#include "TChain.h"
#include "TFile.h"
#include "TKey.h"
#include "TList.h"
#include "TObject.h"
#include "TString.h"
#include "TTree.h"
#include "TSystemDirectory.h"



// * ================================ * //
// * ------- CLASS DEFINITION ------- * //
// * ================================ * //
class BOSSRootChain
{
public:
	// * Constructor and destructors *
	BOSSRootChain();
	BOSSRootChain(const char* directoryPath, const char* analysisName);
	~BOSSRootChain();

	// * Information *
	void Print(const char* nameOfChain, Option_t *option = "toponly");
	void Print();
	void PrintWithOption(Option_t *option);
	void PrintFiles();
	void PrintTrees(Option_t *option = "");

	// * Getters *
	std::list<TChain*>& GetListOfChains();
	size_t  GetNumberOfChains() { return fChains.size(); };
	size_t  GetNumberOfFiles() { return fFileNames.size(); };
	int     GetNumberOfEvents(const char* treeName);
	TChain* FindChain(const char* treeName);

protected:
	// * Data members *
	TString fDirectoryPath;
	//!< The path of the directory that was was used to load the ROOT files and generate the `TChain`s in this object.
	TString fAnalysisName;
	//!< Indicator for analysis type (like `rhopi`) that was used to load the ROOT files in this objects.
	std::list<TChain*> fChains;
	//!< List of pointers to chains that resemble the trees in the files.
	std::list<TString> fFileNames;
	//!< List of filenames that were loaded from the directory.

	// * Private members
	void Initialize();
	void Destruct();
	void LoadChains();
	template<class T>
	void SetBranchAddress(TChain* chain, const char* branchName, T& address);

};



// * =========================================== * //
// * ------- CONSTRUCTORS AND DESTRUCTORS ------ * //
// * =========================================== * //

/**
 * @brief Default constructor.
 * @details Currently does nothing as there are no null pointers to set.
 */
BOSSRootChain::BOSSRootChain()
{
	Initialize();
}

/**
 * @brief Constructor that creates `TChain`s from files in a system directory.
 * @details Feed this constructor a directory path and a string that you should occur in the ROOT files within this directory. All files that contain `_+<name of your analysis>+_` and are not zombie will be added to the list of files. After this, an inventory will be made of all TTrees contained within these files. A `TChain` will be made for each TTree that is contained within the first file that was loaded.
 */
BOSSRootChain::BOSSRootChain(const char* pathDirectory, const char* analysisName) :
	fDirectoryPath(pathDirectory),
	fAnalysisName(analysisName)
{
	// * Initialize members *
	Initialize();
	// * Set filename pattern *
	TString analysisNameString(analysisName);
	analysisNameString.Prepend("_");
	analysisNameString.Append("_");
	if(fDirectoryPath.EndsWith("/")) fDirectoryPath.Chop(); // remove trailing slash from path
	// * Make an inventory of ROOT files in the directory that satisfy your requirements *
	TSystemDirectory dir(pathDirectory, pathDirectory); // open file directory
	TList *files = dir.GetListOfFiles();
	if (files) {
		TIter fileIter(files);
		TObject *obj;
		TSystemFile *systemFile;
		while ((obj = fileIter())) {
			systemFile = dynamic_cast<TSystemFile*>(obj);
			TString fname(systemFile->GetName());
			if(fname.Contains(analysisName)) {
				// * add file name if file exists and is no zombie
				TFile file((fDirectoryPath+"/"+"/"+fname).Data());
				if(!file.IsZombie()) fFileNames.push_back(fname);
			}
		}
	} else {
		std::cout << "ERROR: Directory \"" << fDirectoryPath << "\" does not exist" << std::endl;
		return;
	}
	// * Load TChains *
	LoadChains();
}

/**
 * @brief Destructor.
 * @details Currently does nothing, as there are no pointer data members.
 */
BOSSRootChain::~BOSSRootChain()
{
	Destruct();
}

/**
 * @brief Encapsulation of the default constructor.
 * @details Sets or resets all data members
 */
void BOSSRootChain::Initialize()
{
}

/**
 * @brief Encapsulation of the default destructor.
 * @details Goes through the list of chains and destroys each of them, then clears the list. Note that just clearing the list would not be sufficient, as its members are pointers.
 */
void BOSSRootChain::Destruct()
{
	std::list<TChain*>::iterator it = fChains.begin();
	while (it != fChains.end()) {
		delete *it;
		++it;
	}
	fChains.clear();
}


// * ======================= * //
// * ------- GETTERS ------- * //
// * ======================= * //

/**
 * @brief Get this object's list of chains.
 * @return std::list<TChain*>& Reference to the list of chains in this object.
 */
std::list<TChain*>& BOSSRootChain::GetListOfChains()
{
	return fChains;
}

/**
 * @brief Get the number of events in one of the `TChain`s.
 * @param treeName Name of the `TTree` that you are looking for.
 * @return int Chain object that contains the trees. Returns a `nullptr` if this `TChain` does not exist.
 */
int BOSSRootChain::GetNumberOfEvents(const char* treeName)
{
	TChain* chain = FindChain(treeName);
	if(chain) return chain->GetEntries();
	return 0;
}

/**
 * @brief Look for a tree in the files and get its `TChain`.
 * @param treeName Name of the `TTree` that you are looking for.
 * @return TChain* Chain object that contains the trees. Returns a `nullptr` if this `TChain` does not exist.
 */
TChain* BOSSRootChain::FindChain(const char* treeName)
{
	// * Loop over list of TChains *
	std::list<TChain*>::iterator it = fChains.begin();
	while(it != fChains.end()) {
		TString name = (*it)->GetName();
		if(name.EqualTo(treeName)) return *it;
		++it;
	}
	// * Output if there is no chain of this name
	return nullptr;
}




// * =========================== * //
// * ------- INFORMATION ------- * //
// * =========================== * //

/**
 * @brief Print information about a certan tree (`TChain`).
 * @details This function loops over the list of file names and over the list of chains and prints its name and number of events. For each chain, information about its branches is also printed.
 * @param nameOfChain
 * @param option
 */
void BOSSRootChain::Print(const char* nameOfChain, Option_t *option)
{
	TChain* chain = FindChain(nameOfChain);
	if(chain) {
		chain->Print(option);
		std::cout << "------------------------------------" << std::endl;
		std::cout << "Total number of events in tree \"" << chain->GetName() << "\": " << std::scientific << chain->GetEntries() << std::endl;
	}
	else std::cout << "Chain \"" << nameOfChain << "\" does not exist" << std::endl;
	std::cout << std::endl;
}

/**
 * @brief Print information about all files and trees that were loaded.
 * @details This function loops over the list of file names and over the list of chains and prints its name and number of events. For each chain, information about its branches is also printed.
 */
void BOSSRootChain::Print()
{
	PrintFiles();
	PrintTrees("toponly"); // see https://root.cern.ch/doc/master/classTTree.html
}

/**
 * @brief Print information about all files and trees that were loaded.
 * @details This function loops over the list of file names and over the list of chains and prints its name and number of events. For each chain, information about its branches is also printed.
 */
void BOSSRootChain::PrintWithOption(Option_t *option)
{
	PrintFiles();
	PrintTrees(option);
}

/**
 * @brief Print all file names of files that are in the directory you loaded.
 */
void BOSSRootChain::PrintFiles()
{
	if(!fFileNames.size()) {
		std::cout << std::endl << "No files were loaded" << std::endl;
		return;
	} else {
		std::cout << std::endl << "This object contains " << fFileNames.size() << " files:" << std::endl;
		std::list<TString>::iterator it = fFileNames.begin();
		while (it != fFileNames.end()) {
			std::cout << " - \"" << *it << "\"" << std::endl;
			++it;
		}
	}
}

/**
 * @brief Print all chains (and their branch information) that were created from the files in the directory you loaded.
 */
void BOSSRootChain::PrintTrees(Option_t *option)
{
	if(!fFileNames.size()) {
		std::cout << std::endl << "No chains / trees were loaded" << std::endl;
		return;
	} else {
		std::cout << std::endl << "This object contains " << fChains.size() << " chains / trees:" << std::endl;
		std::list<TChain*>::iterator it = fChains.begin();
		int i = 1;
		while (it != fChains.end()) {
			// * Print info line per chain
			std::cout << std::endl << "___________________________________________" << std::endl;
			std::cout << std::endl
				<< "Chain " << i << " \"" << (*it)->GetName() << "\" (" << (*it)->GetEntries() << " events, " << (*it)->GetListOfBranches()->GetEntries() << " branches):" << std::endl;
			std::cout << "___________________________________________" << std::endl;
			// * Print branch info
			(*it)->Print(option);
			// * Iterators
			++it; // increase iterator
			++i;  // increase counter
		}
	}
}




// * =============================== * //
// * ------- PRIVATE METHODS ------- * //
// * =============================== * //

/**
 * @brief Create a list of `TChain`s based on the files in the directory you are loading
 * @details The first file in the directory is used to make an inventory of all trees within the file. The names of these trees are used to create the `TChain`s.
 */
void BOSSRootChain::LoadChains()
{
	// * Attempt to load one of the files *
	if(!fFileNames.size()) {
		std::cout << "ERROR: List of file names is empty!" << std::endl;
		std::cout << "--> There were no ROOT files in directory \"" << fDirectoryPath << " satisfying the \"" << fAnalysisName << "\" pattern" << std::endl;
	}
	TString fileToLoad(fDirectoryPath+"/"+fFileNames.front());
	TFile file(fileToLoad.Data());
	if(file.IsZombie()) {
		std::cout << "ERROR: File \"" << fileToLoad << "\" is zombie" << std::endl;
	}
	// * Go through keys in the file and add create TChain if it is a TTree *
	TIter next(file.GetListOfKeys());
	TObject *obj  = nullptr;
	TKey    *key  = nullptr;
	TTree   *tree = nullptr;
	while((obj = next())) {
		if((key = dynamic_cast<TKey*>(obj))) { // attempt to cast to TKey
			if((tree = dynamic_cast<TTree*>(key->ReadObj()))) { // read TKey and attempt to cast to TTree
				TChain* chain = new TChain(tree->GetName());
				// * Loop over file names and at them to the chain
				std::list<TString>::iterator it = fFileNames.begin();
				while(it != fFileNames.end()) {
					chain->Add(fDirectoryPath+"/"+(*it)); // add ROOT file
					++it;
				}
				// * Add chain pointer to the list
				fChains.push_back(chain);
			}
		}
	}
	// * Output *
	std::cout
		<< "Created a list of " << fChains.size() << " TChains based on file \"" << file.GetName() << "\""
		<< " with " << fFileNames.size() << " ROOT files linked to them" << std::endl;
}

/**
 * @brief Relate an address in the memory to a branch of a `TChain`.
 *
 * @tparam T         Template that can be any type (like `double`, `int`, etc.)
 * @param chain      Pointer to the `TChain` that you want to load a branch from.
 * @param branchName Name of the branch that you are looking.
 * @param address    Type (address) that you want to set.
 */
template<class T>
void BOSSRootChain::SetBranchAddress(TChain* chain, const char* branchName, T& address)
{
	if(!chain) {
		std::cout << "ERROR: TChain* is a null pointer" << std::endl;
		// std::terminate(); // use this if you want the class construction to be strict
	}
	int result = chain->SetBranchAddress(branchName, &address);
	if(result < 0) {
		std::cout << "WARNING: Attempt to load \"" << branchName << "\" from TChain \"" << chain->GetName() << "\" resulted in error code " << result << std::endl;
		// std::terminate(); // use this if you want the class construction to be strict
	}
}

#endif