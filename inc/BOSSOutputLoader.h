#ifndef BOSS_Afterburner_BOSSOutputLoader_H
#define BOSS_Afterburner_BOSSOutputLoader_H

// * ========================= * //
// * ------- LIBRARIES ------- * //
// * ========================= * //
	#include "ChainLoader.h"
	#include "TChain.h"
	#include "TString.h"
	#include <list>
	#include <string>
	#include <unordered_map>



// * ================================= * //
// * ------- CLASS DEFINITIONS ------- * //
// * ================================= * //
/// @addtogroup BOSS_Afterburner_objects
/// @{


	/**
	 * @brief    General container for BOSS analysis output
	 * @author   Remco de Boer 雷穆克 (r.e.deboer@students.uu.nl or remco.de.boer@ihep.ac.cn)
	 * @date     October 24th, 2018
	 *
	 * @details  The BOSSRootTree class can be used to create several trees from ROOT files generated by the `jopOptions_ana` (analysis) step of the BOSS framework in the most general way, that is, it only loads the ROOT files and creates an `unordered_map` of `TChain`s based on @a (all) trees within those ROOT files. You can create a derived class which maps the map of `TChain`s to a structure with particular names that match the file with which you are working.
	 */
	class BOSSOutputLoader
	{
	public:
		// * CONSTRUCTOR AND DESTRUCTORS * //
		BOSSOutputLoader() {}
		BOSSOutputLoader(const char* directoryPath, bool print = true);

		// * INFORMATION * //
		TH1F* DrawBranches(const char* treeName, const char* branchX, const Int_t nBinx, const double x1, const double x2, Option_t* opt="", const TString &setLogx="");
		TH2F* DrawBranches(const char* treeName, const char* branchX, const char* branchY, const Int_t nBinx, const double x1, const double x2, const Int_t nBiny, const double y1, const double y2, Option_t* opt="", const TString &setLogx="");
		bool IsZombie();
		void DrawAndSaveAllBranches(const char* treeName, Option_t* opt="", const TString &logScale="");
		void DrawBranches(const char* treeName, const char* branchNames, Option_t* opt="", const TString &logScale="");
		void Print();
		void Print(const char* nameOfTree, Option_t *opt = "toponly");
		void PrintCutFlow();
		void PrintCuts();
		void PrintTrees(Option_t *opt="");
		void QuickDrawAndSaveAll(Option_t* opt="");

		// * GETTERS * //
		Long64_t GetEntries(const char* treeName);
		Long64_t GetLargestEntries() const;
		ChainLoader& operator[](const char* name) { return fChains.at(name); }
		TChain& FindTree(const char* treeName);
		std::unordered_map<std::string, ChainLoader>& GetChains() { return fChains; }

	protected:
		// * DATA MEMBERS * //
		TString fDirectoryPath; //!< The path of the directory that was was used to load the ROOT files and generate the `TChain`s in this object.
		std::list<TString> fFileNames; //!< List of filenames that were loaded from the directory.
		std::unordered_map<std::string, ChainLoader> fChains; //!< Map of `TChain`s of the loaded ROOT files (contained withing `ChainLoader`).

		// * PRIVATE METHODS * //
		std::list<ChainLoader*> CreateOrderedMap();
		void LoadChains(bool print = true);

	};


/// @}
#endif