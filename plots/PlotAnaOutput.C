/**
 * @brief    Simple plotting script for RhoPi analysis output.
 * @author   Remco de Boer 雷穆克 (r.e.deboer@students.uu.nl or remco.de.boer@ihep.ac.cn)
 * @date     October 25th, 2018
 * @remark   @b DEVELOPMENTAL
 *
 * @details  This macro generates some plots like ToF versus momentum from ROOT files generated by the `analysis` step of the BOSS framework. Comment certain loops in this source code if you do @a {not} want to generate them.
 */


// * ========================= * //
// * ------- LIBRARIES ------- * //
// * ========================= * //
#include <iostream>
#include "TCanvas.h"
#include "TSystem.h"
#include "TH1.h"
#include "TH1D.h"
#include "TH2D.h"
#include "TString.h"
#include "BOSSRootFile.h"
#include "RhopiRootFile.h"


// * ===================================== * //
// * ------- FUNCTION DECLARATIONS ------- * //
// * ===================================== * //
template<class T>
void SetBranchAddress(TTree*, const char*, T&);
void DrawAndSave(TTree*, const char*, const char* s = "", Option_t* o = "");
void DrawSaveAndDelete(TH1D*&, const char*);
void DrawSaveAndDelete(TH2D*&, const char*);


// * ============================= * //
// * ------- MAIN FUNCTION ------- * //
// * ============================= * //
void PlotAnaOutput()
{
	// * Load RhoPi ROOT analysis file *
	RhopiRootFile rhopi("rhopi_ana_data.root");

	// * Some variables *
	Long64_t nentries; // will be used when looping over TTrees

	// * Set branching addresses *
	// ! Modify these according to your ROOT file
		// * Vertex position (vxyz / m_tuple1)
			SetBranchAddress(rhopi.vxyz(), "vx0",    vxyz::vx0);    // primary x-vertex as determined by MDC
			SetBranchAddress(rhopi.vxyz(), "vy0",    vxyz::vy0);    // primary y-vertex as determined by MDC
			SetBranchAddress(rhopi.vxyz(), "vz0",    vxyz::vz0);    // primary z-vertex as determined by MDC
			SetBranchAddress(rhopi.vxyz(), "vr0",    vxyz::vr0);    // distance from origin in xy-plane
			SetBranchAddress(rhopi.vxyz(), "rvxy0",  vxyz::rvxy0);  // nearest distance to IP in xy plane
			SetBranchAddress(rhopi.vxyz(), "rvz0",   vxyz::rvz0);   // nearest distance to IP in z direction
			SetBranchAddress(rhopi.vxyz(), "rvphi0", vxyz::rvphi0); // angle in the xy-plane (?)
		// * Photon information (photon / m_tuple2)
			SetBranchAddress(rhopi.photon(), "dthe", photon::dthe); // theta difference with nearest charged track (degrees)
			SetBranchAddress(rhopi.photon(), "dphi", photon::dphi); // phi difference with nearest charged track (degrees)
			SetBranchAddress(rhopi.photon(), "dang", photon::dang); // angle difference with nearest charged track
			SetBranchAddress(rhopi.photon(), "eraw", photon::eraw); // energy of the photon
		// * dE/dx PID information (dedx / m_tuple7)
			SetBranchAddress(rhopi.dedx(), "ptrk",   dedx::ptrk);   // momentum of the track
			SetBranchAddress(rhopi.dedx(), "chie",   dedx::chie);   // chi2 in case of electron
			SetBranchAddress(rhopi.dedx(), "chimu",  dedx::chimu);  // chi2 in case of muon
			SetBranchAddress(rhopi.dedx(), "chipi",  dedx::chipi);  // chi2 in case of pion
			SetBranchAddress(rhopi.dedx(), "chik",   dedx::chik);   // chi2 in case of kaon
			SetBranchAddress(rhopi.dedx(), "chip",   dedx::chip);   // chi2 in case of proton
			SetBranchAddress(rhopi.dedx(), "probPH", dedx::probPH); // most probable pulse height from truncated mean
			SetBranchAddress(rhopi.dedx(), "normPH", dedx::normPH); // normalized pulse height
			SetBranchAddress(rhopi.dedx(), "ghit",   dedx::ghit);   // number of good hits
			SetBranchAddress(rhopi.dedx(), "thit",   dedx::thit);   // total number of hits
		// * ToF inner barrel information (tof1 / m_tuple9)
			SetBranchAddress(rhopi.tof1(), "ptrk", tof1::ptrk); // momentum of the track as reconstructed by MDC
			SetBranchAddress(rhopi.tof1(), "cntr", tof1::cntr); // ToF counter ID
			SetBranchAddress(rhopi.tof1(), "ph",   tof1::ph);   // ToF pulse height
			SetBranchAddress(rhopi.tof1(), "zhit", tof1::zhit); // track extrapolate Z or R Hit position
			SetBranchAddress(rhopi.tof1(), "qual", tof1::qual); // data quality of reconstruction
			SetBranchAddress(rhopi.tof1(), "te",   tof1::te);   // difference with ToF in electron hypothesis
			SetBranchAddress(rhopi.tof1(), "tmu",  tof1::tmu);  // difference with ToF in muon hypothesis
			SetBranchAddress(rhopi.tof1(), "tpi",  tof1::tpi);  // difference with ToF in charged pion hypothesis
			SetBranchAddress(rhopi.tof1(), "tk",   tof1::tk);   // difference with ToF in charged kaon hypothesis
			SetBranchAddress(rhopi.tof1(), "tp",   tof1::tp);   // difference with ToF in proton hypothesis
		// * ToF outer barrel information (tof2 / m_tuple10)
			SetBranchAddress(rhopi.tof2(), "ptrk", tof2::ptrk); // momentum of the track as reconstructed by MDC
			SetBranchAddress(rhopi.tof2(), "cntr", tof2::cntr); // ToF counter ID
			SetBranchAddress(rhopi.tof2(), "ph",   tof2::ph);   // ToF pulse height
			SetBranchAddress(rhopi.tof2(), "zhit", tof2::zhit); // track extrapolate Z or R Hit position
			SetBranchAddress(rhopi.tof2(), "qual", tof2::qual); // data quality of reconstruction
			SetBranchAddress(rhopi.tof2(), "te",   tof2::te);   // difference with ToF in electron hypothesis
			SetBranchAddress(rhopi.tof2(), "tmu",  tof2::tmu);  // difference with ToF in muon hypothesis
			SetBranchAddress(rhopi.tof2(), "tpi",  tof2::tpi);  // difference with ToF in charged pion hypothesis
			SetBranchAddress(rhopi.tof2(), "tk",   tof2::tk);   // difference with ToF in charged kaon hypothesis
			SetBranchAddress(rhopi.tof2(), "tp",   tof2::tp);   // difference with ToF in proton hypothesis
		// * Particle Identification (pid / m_tuple11)
			SetBranchAddress(rhopi.pid(), "ptrk", pid::ptrk); // momentum of the track
			SetBranchAddress(rhopi.pid(), "cost", pid::cost); // theta angle of the track
			SetBranchAddress(rhopi.pid(), "dedx", pid::dedx); // Chi squared of the dedx of the track
			SetBranchAddress(rhopi.pid(), "tof1", pid::tof1); // Chi squared of the inner barrel ToF of the track
			SetBranchAddress(rhopi.pid(), "tof2", pid::tof2); // Chi squared of the outer barrel ToF of the track
			SetBranchAddress(rhopi.pid(), "prob", pid::prob); // probability that it is a pion
		// * Total energy (etot / m_tuple3)
			SetBranchAddress(rhopi.etot(), "m2gg", etot::m2gg); // invariant mass of the two gammas
			SetBranchAddress(rhopi.etot(), "etot", etot::etot); // total energy of pi^+, pi^ and the two gammas
		// * Fit pi^0 information from EMCal (fit4c / m_tuple4)
			SetBranchAddress(rhopi.fit4c(), "mpi0", fit4c::mpi0); // invariant pi0 mass according to Kalman kinematic fit
			SetBranchAddress(rhopi.fit4c(), "chi2", fit4c::chi2); // chi square of the Kalman kinematic fit
		// * Fit rho^0, rho^+, rho^- inv. mass from EMCal (fit5c / m_tuple5)
			SetBranchAddress(rhopi.fit5c(), "chi2", fit5c::chi2); // chi squared of the Kalman kinematic fit
			SetBranchAddress(rhopi.fit5c(), "mrh0", fit5c::mrho0); // inv. mass pi^+ pi^- (rho^0)
			SetBranchAddress(rhopi.fit5c(), "mrhp", fit5c::mrhop); // inv. mass pi^0 pi^+ (rho^+)
			SetBranchAddress(rhopi.fit5c(), "mrhm", fit5c::mrhom); // inv. mass pi^0 pi^- (rho^-)
		// * Photon detection efficiency info (geff / m_tuple6)
			SetBranchAddress(rhopi.geff(), "fcos", geff::fcos); // E/p ratio for pi^0 candidate
			SetBranchAddress(rhopi.geff(), "elow", geff::elow); // lowest energy of the two gammas
		// * ToF end cap information (tofe / m_tuple8)
			SetBranchAddress(rhopi.tofe(), "ptrk", tofe::ptrk); // momentum of the track as reconstructed by MDC
			SetBranchAddress(rhopi.tofe(), "cntr", tofe::cntr); // ToF counter ID
			SetBranchAddress(rhopi.tofe(), "ph",   tofe::ph);   // ToF pulse height
			SetBranchAddress(rhopi.tofe(), "rhit", tofe::rhit); // track extrapolate Z or R Hit position
			SetBranchAddress(rhopi.tofe(), "qual", tofe::qual); // data quality of reconstruction
			SetBranchAddress(rhopi.tofe(), "te",   tofe::te);   // difference with ToF in electron hypothesis
			SetBranchAddress(rhopi.tofe(), "tmu",  tofe::tmu);  // difference with ToF in muon hypothesis
			SetBranchAddress(rhopi.tofe(), "tpi",  tofe::tpi);  // difference with ToF in charged pion hypothesis
			SetBranchAddress(rhopi.tofe(), "tk",   tofe::tk);   // difference with ToF in charged kaon hypothesis
			SetBranchAddress(rhopi.tofe(), "tp",   tofe::tp);   // difference with ToF in proton hypothesis

	// * Set png output directory *
	// ! Set these depending on which histograms you save
		gSystem->mkdir("png");
		gSystem->mkdir("png/branches");
		gSystem->mkdir("png/tof1");
		gSystem->mkdir("png/tof2");
		gSystem->mkdir("png/fit4c");
		gSystem->mkdir("png/fit5c");

	// * Generate inner barrel ToF plots *
		// * Create histograms
			TH2D* histTof1_e = new TH2D("tof1_e",
				"Inner barrel ToF (electron hypothesis);#it{p} (GeV/#it{c});ToF (ns)",
				80,   0.,  2., // momentum bins
				40, -20., 50.  // ToF difference bins
			);
			TH2D* histTof1_mu = new TH2D("tof1_mu",
				"Inner barrel ToF (muon hypothesis);#it{p} (GeV/#it{c});ToF (ns)",
				80,   0.,  2., // momentum bins
				40, -50., 50.  // ToF difference bins
			);
			TH2D* histTof1_pi = new TH2D("tof1_pi",
				"Inner barrel ToF (pion hypothesis);#it{p} (GeV/#it{c});ToF (ns)",
				80,   0.,  2., // momentum bins
				40, -30., 50.  // ToF difference bins
			);
			TH2D* histTof1_k = new TH2D("tof1_k",
				"Inner barrel ToF (kaon hypothesis);#it{p} (GeV/#it{c});ToF (ns)",
				80,    0.,  2., // momentum bins
				40, -250., 50.  // ToF difference bins
			);
			TH2D* histTof1_p = new TH2D("tof1_p",
				"Inner barrel ToF (proton hypothesis);#it{p} (GeV/#it{c});ToF (ns)",
				80,    0.,  2., // momentum bins
				40, -500., 50.  // ToF difference bins
			);
		// * Loop over tof1 TTree
			nentries = rhopi.tof1()->GetEntries();
			std::cout << "Looping over " << nentries << " entries in TTree \"" << rhopi.tof1()->GetName() << "\"" << std::endl;
			for (Long64_t i=0; i < nentries; i++ ) {
				rhopi.tof1()->GetEntry(i);
				histTof1_e ->Fill(tof1::ptrk, 50*tof1::te);  // one ToF unit is 50 ns
				histTof1_mu->Fill(tof1::ptrk, 50*tof1::tmu); // one ToF unit is 50 ns
				histTof1_pi->Fill(tof1::ptrk, 50*tof1::tpi); // one ToF unit is 50 ns
				histTof1_k ->Fill(tof1::ptrk, 50*tof1::tk);  // one ToF unit is 50 ns
				histTof1_p ->Fill(tof1::ptrk, 50*tof1::tp);  // one ToF unit is 50 ns
			}
		// * Draw and save histograms
			DrawSaveAndDelete(histTof1_e,  "png/tof1/histTof1_e.png");
			DrawSaveAndDelete(histTof1_mu, "png/tof1/histTof1_mu.png");
			DrawSaveAndDelete(histTof1_pi, "png/tof1/histTof1_pi.png");
			DrawSaveAndDelete(histTof1_k,  "png/tof1/histTof1_k.png");
			DrawSaveAndDelete(histTof1_p,  "png/tof1/histTof1_p.png");

	// * Generate outer barrel ToF plots *
		// * Create histograms
			TH2D* histTof2_e = new TH2D("tof2_e",
				"Outer barrel ToF (electron hypothesis);#it{p} (GeV/#it{c});ToF (ns)",
				80,   0.,  2., // momentum bins
				40, -20., 50.  // ToF difference bins
			);
			TH2D* histTof2_mu = new TH2D("tof2_mu",
				"Outer barrel ToF (muon hypothesis);#it{p} (GeV/#it{c});ToF (ns)",
				80,   0.,  2., // momentum bins
				40, -50., 50.  // ToF difference bins
			);
			TH2D* histTof2_pi = new TH2D("tof2_pi",
				"Outer barrel ToF (pion hypothesis);#it{p} (GeV/#it{c});ToF (ns)",
				80,   0.,  2., // momentum bins
				40, -30., 50.  // ToF difference bins
			);
			TH2D* histTof2_k = new TH2D("tof2_k",
				"Outer barrel ToF (kaon hypothesis);#it{p} (GeV/#it{c});ToF (ns)",
				80,    0.,  2., // momentum bins
				40, -250., 50.  // ToF difference bins
			);
			TH2D* histTof2_p = new TH2D("tof2_p",
				"Outer barrel ToF (proton hypothesis);#it{p} (GeV/#it{c});ToF (ns)",
				80,    0.,  2., // momentum bins
				40, -500., 50.  // ToF difference bins
			);
		// * Loop over tof2 TTree
			nentries = rhopi.tof2()->GetEntries();
			std::cout << "Looping over " << nentries << " entries in TTree \"" << rhopi.tof2()->GetName() << "\"" << std::endl;
			for (Long64_t i=0; i < nentries; i++ ) {
				rhopi.tof2()->GetEntry(i);
				histTof2_e ->Fill(tof2::ptrk, 50*tof2::te);  // one ToF unit is 50 ns
				histTof2_mu->Fill(tof2::ptrk, 50*tof2::tmu); // one ToF unit is 50 ns
				histTof2_pi->Fill(tof2::ptrk, 50*tof2::tpi); // one ToF unit is 50 ns
				histTof2_k ->Fill(tof2::ptrk, 50*tof2::tk);  // one ToF unit is 50 ns
				histTof2_p ->Fill(tof2::ptrk, 50*tof2::tp);  // one ToF unit is 50 ns
			}
		// * Draw and save histograms
			DrawSaveAndDelete(histTof2_e,  "png/tof2/histTof2_e.png");
			DrawSaveAndDelete(histTof2_mu, "png/tof2/histTof2_mu.png");
			DrawSaveAndDelete(histTof2_pi, "png/tof2/histTof2_pi.png");
			DrawSaveAndDelete(histTof2_k,  "png/tof2/histTof2_k.png");
			DrawSaveAndDelete(histTof2_p,  "png/tof2/histTof2_p.png");

	// * Fit 4 inv. mass plots (pi^0) *
		// * Create histogram
			TH1D* histFit4c_mpi0 = new TH1D("fit4c_mpi0",
				"Invariant mass as determined with fit4c (#pi^0 candidate);#it{M_{#gamma#gamma}} (GeV/#it{c}^{2});counts",
				150, 0., .25
			);
		// * Loop over tof2 TTree
			nentries = rhopi.fit4c()->GetEntries();
			std::cout << "Looping over " << nentries << " entries in TTree \"" << rhopi.fit4c()->GetName() << "\"" << std::endl;
			for (Long64_t i=0; i < nentries; i++ ) {
				rhopi.fit4c()->GetEntry(i);
				histFit4c_mpi0->Fill(fit4c::mpi0);
			}
		// * Draw and save histograms
			DrawSaveAndDelete(histFit4c_mpi0, "png/fit4c/histFit4c_mpi0.png");

	// * Fit 5 inv. mass plots (rho^0, rho^+, and rho^-) *
		// * Create histogram
			TH1D* histFit5c_mrho0 = new TH1D("fit5c_mrho0",
				"Invariant mass as determined with fit5c (#rho^{0} candidate);#it{M_{#pi^{-}#pi^{+}}} (GeV/#it{c}^{2});counts",
				150, 0.3, 3.
			);
			TH1D* histFit5c_mrhom = new TH1D("fit5c_mrhom",
				"Invariant mass as determined with fit5c (#rho^{-} candidate);#it{M_{#pi^{0}#pi^{-}}} (GeV/#it{c}^{2});counts",
				150, 0.3, 3.
			);
			TH1D* histFit5c_mrhop = new TH1D("fit5c_mrhop",
				"Invariant mass as determined with fit5c (#rho^{+} candidate);#it{M_{#pi^{0}#pi^{+}}} (GeV/#it{c}^{2});counts",
				150, 0.3, 3.
			);
			TH2D* histFit5c_dalitz_rhom_rho0 = new TH2D("fit5c_dalitz_rhom_rho0",
				"Dalitz plot (#rho^{-} vs #rho^{0} candidate);#it{M_{#pi^{0}#pi^{-}}} (GeV/#it{c}^{2});#it{M_{#pi^{-}#pi^{+}}} (GeV/#it{c}^{2});counts",
				80, 0.3, 3.,
				80, 0.3, 3.
			);
			TH2D* histFit5c_dalitz_rhop_rho0 = new TH2D("fit5c_dalitz_rhop_rho0",
				"Dalitz plot (#rho^{+} vs #rho^{0} candidate);#it{M_{#pi^{0}#pi^{+}}} (GeV/#it{c}^{2});#it{M_{#pi^{-}#pi^{+}}} (GeV/#it{c}^{2});counts",
				80, 0.3, 3.,
				80, 0.3, 3.
			);
			TH2D* histFit5c_dalitz_rhom_rhop = new TH2D("fit5c_dalitz_rhom_rhop",
				"Dalitz plot (#rho^{-} vs #rho^{+} candidate);#it{M_{#pi^{0}#pi^{-}}} (GeV/#it{c}^{2});#it{M_{#pi^{0}#pi^{+}}} (GeV/#it{c}^{2});counts",
				80, 0.3, 3.,
				80, 0.3, 3.
			);
		// * Loop over tof2 TTree
			nentries = rhopi.fit5c()->GetEntries();
			std::cout << "Looping over " << nentries << " entries in TTree \"" << rhopi.fit5c()->GetName() << "\"" << std::endl;
			for (Long64_t i=0; i < nentries; i++ ) {
				rhopi.fit5c()->GetEntry(i);
				histFit5c_mrho0->Fill(fit5c::mrho0);
				histFit5c_mrhom->Fill(fit5c::mrhom);
				histFit5c_mrhop->Fill(fit5c::mrhop);
				histFit5c_dalitz_rhom_rho0->Fill(fit5c::mrhom, fit5c::mrho0);
				histFit5c_dalitz_rhop_rho0->Fill(fit5c::mrhop, fit5c::mrho0);
				histFit5c_dalitz_rhom_rhop->Fill(fit5c::mrhom, fit5c::mrhop);
			}
		// * Draw and save histograms
			DrawSaveAndDelete(histFit5c_mrho0, "png/fit5c/histFit5c_mrho0.png");
			DrawSaveAndDelete(histFit5c_mrhom, "png/fit5c/histFit5c_mrhom.png");
			DrawSaveAndDelete(histFit5c_mrhop, "png/fit5c/histFit5c_mrhop.png");
			DrawSaveAndDelete(histFit5c_dalitz_rhom_rho0, "png/fit5c/histFit5c_dalitz_rhom_rho0.png");
			DrawSaveAndDelete(histFit5c_dalitz_rhop_rho0, "png/fit5c/histFit5c_dalitz_rhop_rho0.png");
			DrawSaveAndDelete(histFit5c_dalitz_rhom_rhop, "png/fit5c/histFit5c_dalitz_rhom_rhop.png");

	// * TEMP *
		// // * Get entry
		// chain_da->GetEntry(i);
		// // * Compute 4-momenta
		// gam0.SetPxPyPzE(Pgam_5c[0][0], Pgam_5c[0][1], Pgam_5c[0][2], Pgam_5c[0][3]); // first gamma
		// gam1.SetPxPyPzE(Pgam_5c[1][0], Pgam_5c[1][1], Pgam_5c[1][2], Pgam_5c[1][3]); // second gamma
		// // gam0_mc.SetPxPyPzE(Pgam_mc[0][0], Pgam_mc[0][1], Pgam_mc[0][2], Pgam_mc[0][3]);
		// // gam1_mc.SetPxPyPzE(Pgam_mc[1][0], Pgam_mc[1][1], Pgam_mc[1][2], Pgam_mc[1][3]);
		// ppim.SetPxPyPzE(Ppim_5c[0],Ppim_5c[1],Ppim_5c[2],Ppim_5c[3]);
		// ppip.SetPxPyPzE(Ppip_5c[0],Ppip_5c[1],Ppip_5c[2],Ppip_5c[3]);
		// pi0 = gam0+gam1;
		// // * Compute invariant mass of the f0(1070) resonance
		// mpi0  = (gam0+gam1).M();
		// mrho0 = (ppim+ppip).M();
		// mrhop = (ppip+pi0) .M();
		// mrhom = (pi0+ppim) .M();
		// // mrhom = (ppim+gam0+gam1).M();
		// // mrhop = (ppip+gam0+gam1).M();
		// // * Apply cuts
		// if(chisq>20) continue;
		// if(fabs(mpi0-Mpi0)>0.015) continue;
		// // if(fabs(mrho0-Mrho0)>0.15) continue;
		// if(EP_pip>0.8 || EP_pim>0.8) continue;
		// // Ppi0   = sqrt(pi0.E()*pi0.E()-Mpi0*Mpi0);
		// // costhe = fabs(gam1_mc.E()-gam0_mc.E())/Ppi0;
		// // h_Ppi0-      >Fill(Ppi0);
		// // h_costhe    ->Fill(costhe);
		// // h_Ppi0      ->Fill(Ppi0);
		// // h_costhe_run->Fill(costhe, run);
		// // * Fill histogram
		// h_mrho0_da->Fill(mrho0);
		// h_mrhom_da->Fill(mrhom);
		// h_mrhop_da->Fill(mrhop);
		// h_mpi0_da ->Fill(mpi0);
		// h_dalitz  ->Fill(mrhom, mrhop);
		// // h_Egam_da->Fill(min2(gam0_mc.E(), gam1_mc.E()));
		// ++nCut1;


	// * Draw and save branches with a simple method *
		// * Vertex position (vxyz / m_tuple1)
			// DrawAndSave(rhopi.vxyz(),   "vx0");
			// DrawAndSave(rhopi.vxyz(),   "vy0");
			// DrawAndSave(rhopi.vxyz(),   "vz0");
			// DrawAndSave(rhopi.vxyz(),   "vr0");
			// DrawAndSave(rhopi.vxyz(),   "rvxy0");
			// DrawAndSave(rhopi.vxyz(),   "rvz0");
			// DrawAndSave(rhopi.vxyz(),   "rvphi0");
		// * Photon information (photon / m_tuple2)
			// DrawAndSave(rhopi.photon(), "dthe");
			// DrawAndSave(rhopi.photon(), "dphi");
			// DrawAndSave(rhopi.photon(), "dang");
			// DrawAndSave(rhopi.photon(), "eraw");
		// * dE/dx PID information (dedx / m_tuple7)
			// DrawAndSave(rhopi.dedx(),   "ptrk");
			// DrawAndSave(rhopi.dedx(),   "chie");
			// DrawAndSave(rhopi.dedx(),   "chimu");
			// DrawAndSave(rhopi.dedx(),   "chipi");
			// DrawAndSave(rhopi.dedx(),   "chik");
			// DrawAndSave(rhopi.dedx(),   "chip");
			// DrawAndSave(rhopi.dedx(),   "probPH");
			// DrawAndSave(rhopi.dedx(),   "normPH");
			// DrawAndSave(rhopi.dedx(),   "ghit");
			// DrawAndSave(rhopi.dedx(),   "thit");
		// * ToF inner barrel information (tof1 / m_tuple9)
			// DrawAndSave(rhopi.tof1(),   "ptrk");
			// DrawAndSave(rhopi.tof1(),   "cntr");
			// DrawAndSave(rhopi.tof1(),   "ph");
			// DrawAndSave(rhopi.tof1(),   "zhit");
			// DrawAndSave(rhopi.tof1(),   "qual");
			// DrawAndSave(rhopi.tof1(),   "te");
			// DrawAndSave(rhopi.tof1(),   "tmu");
			// DrawAndSave(rhopi.tof1(),   "tpi");
			// DrawAndSave(rhopi.tof1(),   "tk");
			// DrawAndSave(rhopi.tof1(),   "tp");
		// * ToF outer barrel information (tof2 / m_tuple10)
			// DrawAndSave(rhopi.tof2(),   "ptrk");
			// DrawAndSave(rhopi.tof2(),   "cntr");
			// DrawAndSave(rhopi.tof2(),   "ph");
			// DrawAndSave(rhopi.tof2(),   "zhit");
			// DrawAndSave(rhopi.tof2(),   "qual");
			// DrawAndSave(rhopi.tof2(),   "te");
			// DrawAndSave(rhopi.tof2(),   "tmu");
			// DrawAndSave(rhopi.tof2(),   "tpi");
			// DrawAndSave(rhopi.tof2(),   "tk");
			// DrawAndSave(rhopi.tof2(),   "tp");
		// * Particle Identification (pid / m_tuple11)
			// DrawAndSave(rhopi.pid(),    "ptrk");
			// DrawAndSave(rhopi.pid(),    "cost");
			// DrawAndSave(rhopi.pid(),    "dedx");
			// DrawAndSave(rhopi.pid(),    "tof1");
			// DrawAndSave(rhopi.pid(),    "tof2");
			// DrawAndSave(rhopi.pid(),    "prob");
		// * Total energy (etot / m_tuple3)
			// DrawAndSave(rhopi.etot(),   "m2gg");
			// DrawAndSave(rhopi.etot(),   "etot");
		// * Fit pi^0 information from EMCal (fit4c / m_tuple4)
			// DrawAndSave(rhopi.fit4c(),  "chi2");
			// DrawAndSave(rhopi.fit4c(),  "mpi0");
		// * Fit rho^0, rho^+, rho^- inv. mass from EMCal (fit5c / m_tuple5)
			// DrawAndSave(rhopi.fit5c(),  "chi2");
			// DrawAndSave(rhopi.fit5c(),  "mrh0");
			// DrawAndSave(rhopi.fit5c(),  "mrhp");
			// DrawAndSave(rhopi.fit5c(),  "mrhm");
		// * Photon detection efficiency info (geff / m_tuple6)
			// DrawAndSave(rhopi.geff(),   "fcos");
			// DrawAndSave(rhopi.geff(),   "elow");
		// * ToF end cap information (tofe / m_tuple8)
			// DrawAndSave(rhopi.tofe(),   "ptrk");
			// DrawAndSave(rhopi.tofe(),   "cntr");
			// DrawAndSave(rhopi.tofe(),   "ph");
			// DrawAndSave(rhopi.tofe(),   "rhit");
			// DrawAndSave(rhopi.tofe(),   "qual");
			// DrawAndSave(rhopi.tofe(),   "te");
			// DrawAndSave(rhopi.tofe(),   "tmu");
			// DrawAndSave(rhopi.tofe(),   "tpi");
			// DrawAndSave(rhopi.tofe(),   "tk");
			// DrawAndSave(rhopi.tofe(),   "tp");
}


// * ==================================== * //
// * ------- FUNCTION DEFINITIONS ------- * //
// * ==================================== * //
template<class T>
void SetBranchAddress(TTree* tree, const char* branchName, T& address)
{
	if(!tree) {
		std::cout << "ERROR: TTree* is a nullpointer" << std::endl;
		std::terminate();
	}
	if(tree->SetBranchAddress(branchName, &address)) {
		std::cout << "ERROR: Branch \"" << branchName << "\" does not exist in TTree \"" << tree->GetName() << "\"" << std::endl;
		std::terminate();
	}
}
void DrawAndSave(TTree* tree, const char* varexp, const char* selection, Option_t* option)
{
	TCanvas* c = new TCanvas();
	tree->Draw(varexp, selection, option);
	TString outputFileName("png/branches/");
	outputFileName += tree->GetName();
	outputFileName += "_";
	outputFileName += varexp;
	outputFileName += ".png";
	c->SaveAs(outputFileName.Data());
	c->Close();
}
void DrawSaveAndDelete(TH1D*& hist, const char* saveas)
{
	if(!hist) {
		std::cout << "ERROR: fed a nullpointer to DrawSaveAndDelete" << std::endl;
		return;
	}
	TCanvas *c = new TCanvas();
	hist->Draw("ep");
	c->SaveAs(saveas);
	delete c;
	delete hist;
	hist = NULL;
}
void DrawSaveAndDelete(TH2D*& hist, const char* saveas)
{
	if(!hist) {
		std::cout << "ERROR: fed a nullpointer to DrawSaveAndDelete" << std::endl;
		return;
	}
	TCanvas *c = new TCanvas();
	hist->Draw("colz");
	c->SaveAs(saveas);
	delete c;
	delete hist;
	hist = NULL;
}