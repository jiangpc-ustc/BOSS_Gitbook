/**
 * @brief    Simple plotting script for RhoPi analysis output.
 * @author   Remco de Boer 雷穆克 (r.e.deboer@students.uu.nl or remco.de.boer@ihep.ac.cn)
 * @date     October 25th, 2018
 * @remark   @b DEVELOPMENTAL
 *
 * @details  This macro generates some plots like ToF versus momentum from ROOT files generated by the `analysis` step of the BOSS framework. Comment certain loops in this source code if you do @a {not} want to generate them.
 */


// * ======================================== * //
// * ------- LIBRARIES AND NAMESPACES ------- * //
// * ======================================== * //
#include "RooAddPdf.h"
#include "RooBreitWigner.h"
#include "RooDataHist.h"
#include "RooFFTConvPdf.h"
#include "RooFit.h"
#include "RooFitResult.h"
#include "RooGaussian.h"
#include "RooPlot.h"
#include "RooPolynomial.h"
#include "RooRealVar.h"
#include "TApplication.h"
#include "TCanvas.h"
#include "TH1D.h"
#include "TH2D.h"
#include "TString.h"
#include "TSystem.h"
#include "inc/FrameworkSettings.h"
#include "inc/RhopiRootChain.h"
#include <iostream>
using namespace AnaBranches;
using namespace RooFit;


// * ===================================== * //
// * ------- FUNCTION DECLARATIONS ------- * //
// * ===================================== * //
bool CheckIfNullPtr(void* ptr);
void DrawAndSave(TTree*, const char*, const char* s = "", Option_t* o = "");
void DrawAndSave(TH1D*&, const char*);
void DrawAndSave(TH2D*&, const char*);
void DrawSaveAndDelete(TH1D*&, const char*);
void DrawSaveAndDelete(TH1D*&, const TString&);
void DrawSaveAndDelete(TH2D*&, const char*);
void DrawSaveAndDelete(TH2D*&, const TString&);
void FitGaussian(TH1D* invMassPlot, const Particle& particle, const double sigma = .005);
void FitBreitWigner(TH1D* invMassPlot);


// * ============================= * //
// * ------- MAIN FUNCTION ------- * //
// * ============================= * //
/**
 * @brief Main function used when compiling and executing in `ROOT`.
 * @details
 */
void AnalyseRootFile()
{
	std::cout << std::endl; // TEMPORARY print line because of ssh X11 warning message

	// * Load RhoPi ROOT analysis file *
	RhopiRootChain rhopi("../root","ana");

	// * Some variables *
	Long64_t nentries = 0; // will be used when looping over TTrees

	// * Set output directories *
	// ! Set these depending on which histograms you save
		gSystem->mkdir(Settings::Output::Extension.Data());
		gSystem->mkdir((Settings::Output::Extension+"/branches").Data());
		gSystem->mkdir((Settings::Output::Extension+"/tof1").Data());
		gSystem->mkdir((Settings::Output::Extension+"/tof2").Data());
		gSystem->mkdir((Settings::Output::Extension+"/fit4c").Data());
		gSystem->mkdir((Settings::Output::Extension+"/fit5c").Data());

	// * Generate inner barrel ToF plots *
		// * Create histograms
			TH2D* histTof1_e = new TH2D("tof1_e",
				"Inner barrel ToF (electron hypothesis);#it{p} (GeV/#it{c});ToF (ns)",
				80,   0.,  2., // momentum bins
				40, -20., 50.  // ToF difference bins
			);
			TH2D* histTof1_mu = new TH2D("tof1_mu",
				"Inner barrel ToF (muon hypothesis);#it{p} (GeV/#it{c});ToF (ns)",
				80,   0.,  2., // momentum bins
				40, -50., 50.  // ToF difference bins
			);
			TH2D* histTof1_pi = new TH2D("tof1_pi",
				"Inner barrel ToF (pion hypothesis);#it{p} (GeV/#it{c});ToF (ns)",
				80,   0.,  2., // momentum bins
				40, -30., 50.  // ToF difference bins
			);
			TH2D* histTof1_k = new TH2D("tof1_k",
				"Inner barrel ToF (kaon hypothesis);#it{p} (GeV/#it{c});ToF (ns)",
				80,    0.,  2., // momentum bins
				40, -250., 50.  // ToF difference bins
			);
			TH2D* histTof1_p = new TH2D("tof1_p",
				"Inner barrel ToF (proton hypothesis);#it{p} (GeV/#it{c});ToF (ns)",
				80,    0.,  2., // momentum bins
				40, -500., 50.  // ToF difference bins
			);
		// * Loop over tof1 TTree
			nentries = rhopi.tof1()->GetEntries();
			std::cout << "Looping over " << nentries << " entries in TTree \"" << rhopi.tof1()->GetName() << "\"" << std::endl;
			for (Long64_t i=0; i < nentries; i++ ) {
				rhopi.tof1()->GetEntry(i);
				histTof1_e ->Fill(tof1::ptrk, 50*tof1::te);  // one ToF unit is 50 ns
				histTof1_mu->Fill(tof1::ptrk, 50*tof1::tmu); // one ToF unit is 50 ns
				histTof1_pi->Fill(tof1::ptrk, 50*tof1::tpi); // one ToF unit is 50 ns
				histTof1_k ->Fill(tof1::ptrk, 50*tof1::tk);  // one ToF unit is 50 ns
				histTof1_p ->Fill(tof1::ptrk, 50*tof1::tp);  // one ToF unit is 50 ns
			}
		// * Draw and save histograms
			DrawAndSave(histTof1_e,  Settings::Output::Extension+"/tof1/histTof1_e." +Settings::Output::Extension);
			DrawAndSave(histTof1_mu, Settings::Output::Extension+"/tof1/histTof1_mu."+Settings::Output::Extension);
			DrawAndSave(histTof1_pi, Settings::Output::Extension+"/tof1/histTof1_pi."+Settings::Output::Extension);
			DrawAndSave(histTof1_k,  Settings::Output::Extension+"/tof1/histTof1_k." +Settings::Output::Extension);
			DrawAndSave(histTof1_p,  Settings::Output::Extension+"/tof1/histTof1_p." +Settings::Output::Extension);

	// * Generate outer barrel ToF plots *
		// * Create histograms
			TH2D* histTof2_e = new TH2D("tof2_e",
				"Outer barrel ToF (electron hypothesis);#it{p} (GeV/#it{c});ToF (ns)",
				80,   0.,  2., // momentum bins
				40, -20., 50.  // ToF difference bins
			);
			TH2D* histTof2_mu = new TH2D("tof2_mu",
				"Outer barrel ToF (muon hypothesis);#it{p} (GeV/#it{c});ToF (ns)",
				80,   0.,  2., // momentum bins
				40, -50., 50.  // ToF difference bins
			);
			TH2D* histTof2_pi = new TH2D("tof2_pi",
				"Outer barrel ToF (pion hypothesis);#it{p} (GeV/#it{c});ToF (ns)",
				80,   0.,  2., // momentum bins
				40, -30., 50.  // ToF difference bins
			);
			TH2D* histTof2_k = new TH2D("tof2_k",
				"Outer barrel ToF (kaon hypothesis);#it{p} (GeV/#it{c});ToF (ns)",
				80,    0.,  2., // momentum bins
				40, -250., 50.  // ToF difference bins
			);
			TH2D* histTof2_p = new TH2D("tof2_p",
				"Outer barrel ToF (proton hypothesis);#it{p} (GeV/#it{c});ToF (ns)",
				80,    0.,  2., // momentum bins
				40, -500., 50.  // ToF difference bins
			);
		// * Loop over tof2 TTree
			nentries = rhopi.tof2()->GetEntries();
			std::cout << "Looping over " << nentries << " entries in TTree \"" << rhopi.tof2()->GetName() << "\"" << std::endl;
			for (Long64_t i=0; i < nentries; i++ ) {
				rhopi.tof2()->GetEntry(i);
				histTof2_e ->Fill(tof2::ptrk, 50*tof2::te);  // one ToF unit is 50 ns
				histTof2_mu->Fill(tof2::ptrk, 50*tof2::tmu); // one ToF unit is 50 ns
				histTof2_pi->Fill(tof2::ptrk, 50*tof2::tpi); // one ToF unit is 50 ns
				histTof2_k ->Fill(tof2::ptrk, 50*tof2::tk);  // one ToF unit is 50 ns
				histTof2_p ->Fill(tof2::ptrk, 50*tof2::tp);  // one ToF unit is 50 ns
			}
		// * Draw and save histograms
			DrawAndSave(histTof2_e,  Settings::Output::Extension+"/tof2/histTof2_e." +Settings::Output::Extension);
			DrawAndSave(histTof2_mu, Settings::Output::Extension+"/tof2/histTof2_mu."+Settings::Output::Extension);
			DrawAndSave(histTof2_pi, Settings::Output::Extension+"/tof2/histTof2_pi."+Settings::Output::Extension);
			DrawAndSave(histTof2_k,  Settings::Output::Extension+"/tof2/histTof2_k." +Settings::Output::Extension);
			DrawAndSave(histTof2_p,  Settings::Output::Extension+"/tof2/histTof2_p." +Settings::Output::Extension);

	// * Fit 4 inv. mass plots (pi^0) *
		// * Create histogram
			TH1D* histFit4c_mpi0 = new TH1D("fit4c_mpi0",
				"Invariant mass as determined with fit4c (#pi^0 candidate);#it{M_{#gamma#gamma}} (GeV/#it{c}^{2});counts",
				500, 0., .25
			);
		// * Loop over tof2 TTree
			nentries = rhopi.fit4c()->GetEntries();
			std::cout << "Looping over " << nentries << " entries in TTree \"" << rhopi.fit4c()->GetName() << "\"" << std::endl;
			for (Long64_t i=0; i < nentries; i++ ) {
				rhopi.fit4c()->GetEntry(i);
				histFit4c_mpi0->Fill(fit4c::mpi0);
			}
		// * Draw and save histograms
			// DrawAndSave(histFit4c_mpi0, Settings::Output::Extension+"/fit4c/histFit4c_mpi0."+Settings::Output::Extension);
			DrawAndSave(histFit4c_mpi0, Settings::Output::Extension+"/invmass."+Settings::Output::Extension+"(");

	// * Fit 5 inv. mass plots (rho^0, rho^+, and rho^-) *
		// * Create histogram
			TH1D* histFit5c_mrho0 = new TH1D("fit5c_mrho0",
				"Invariant mass as determined with fit5c (#rho^{0} candidate);#it{M_{#pi^{-}#pi^{+}}} (GeV/#it{c}^{2});counts",
				200, 0.3, 3.
			);
			TH1D* histFit5c_mrhom = new TH1D("fit5c_mrhom",
				"Invariant mass as determined with fit5c (#rho^{-} candidate);#it{M_{#pi^{0}#pi^{-}}} (GeV/#it{c}^{2});counts",
				200, 0.3, 3.
			);
			TH1D* histFit5c_mrhop = new TH1D("fit5c_mrhop",
				"Invariant mass as determined with fit5c (#rho^{+} candidate);#it{M_{#pi^{0}#pi^{+}}} (GeV/#it{c}^{2});counts",
				200, 0.3, 3.
			);
			TH2D* histFit5c_dalitz_rhom_rho0 = new TH2D("fit5c_dalitz_rhom_rho0",
				"Dalitz plot (#rho^{-} vs #rho^{0} candidate);#it{M_{#pi^{0}#pi^{-}}} (GeV/#it{c}^{2});#it{M_{#pi^{-}#pi^{+}}} (GeV/#it{c}^{2});counts",
				80, 0.3, 3.,
				80, 0.3, 3.
			);
			TH2D* histFit5c_dalitz_rhop_rho0 = new TH2D("fit5c_dalitz_rhop_rho0",
				"Dalitz plot (#rho^{+} vs #rho^{0} candidate);#it{M_{#pi^{0}#pi^{+}}} (GeV/#it{c}^{2});#it{M_{#pi^{-}#pi^{+}}} (GeV/#it{c}^{2});counts",
				80, 0.3, 3.,
				80, 0.3, 3.
			);
			TH2D* histFit5c_dalitz_rhom_rhop = new TH2D("fit5c_dalitz_rhom_rhop",
				"Dalitz plot (#rho^{-} vs #rho^{+} candidate);#it{M_{#pi^{0}#pi^{-}}} (GeV/#it{c}^{2});#it{M_{#pi^{0}#pi^{+}}} (GeV/#it{c}^{2});counts",
				80, 0.3, 3.,
				80, 0.3, 3.
			);
		// * Loop over tof2 TTree
			nentries = rhopi.fit5c()->GetEntries();
			std::cout << "Looping over " << nentries << " entries in TTree \"" << rhopi.fit5c()->GetName() << "\"" << std::endl;
			for (Long64_t i=0; i < nentries; i++ ) {
				rhopi.fit5c()->GetEntry(i);
				histFit5c_mrho0->Fill(fit5c::mrho0);
				histFit5c_mrhom->Fill(fit5c::mrhom);
				histFit5c_mrhop->Fill(fit5c::mrhop);
				histFit5c_dalitz_rhom_rho0->Fill(fit5c::mrhom, fit5c::mrho0);
				histFit5c_dalitz_rhop_rho0->Fill(fit5c::mrhop, fit5c::mrho0);
				histFit5c_dalitz_rhom_rhop->Fill(fit5c::mrhom, fit5c::mrhop);
			}
		// * Fit
			FitGaussian(histFit4c_mpi0,  Settings::Particles::Pi0);
			FitGaussian(histFit5c_mrho0, Settings::Particles::Rho0);

		// * Draw and save histograms
			DrawAndSave(histFit5c_mrho0, Settings::Output::Extension+"/invmass."+Settings::Output::Extension);
			DrawAndSave(histFit5c_mrhom, Settings::Output::Extension+"/invmass."+Settings::Output::Extension);
			DrawAndSave(histFit5c_mrhop, Settings::Output::Extension+"/invmass."+Settings::Output::Extension+")");
			DrawAndSave(histFit5c_dalitz_rhom_rho0, Settings::Output::Extension+"/fit5c/histFit5c_dalitz_rhom_rho0."+Settings::Output::Extension);
			DrawAndSave(histFit5c_dalitz_rhop_rho0, Settings::Output::Extension+"/fit5c/histFit5c_dalitz_rhop_rho0."+Settings::Output::Extension);
			DrawAndSave(histFit5c_dalitz_rhom_rhop, Settings::Output::Extension+"/fit5c/histFit5c_dalitz_rhom_rhop."+Settings::Output::Extension);

	gApplication->Terminate();

}

/**
 * @brief Main function used when executing the executable directory (i.e. outside `ROOT`).
 * @details Execute the executable in `bash` for instance using `./AnalyseRootFile`. No arguments required.
 */
int main()
{
	AnalyseRootFile();
}

// * ==================================== * //
// * ------- FUNCTION DEFINITIONS ------- * //
// * ==================================== * //
bool CheckIfNullPtr(void* ptr)
{
	if(!ptr) {
		std::cout << "ERROR: fed a nullpointer" << std::endl;
		return true;
	}
	return false;
}
void DrawAndSave(TTree* tree, const char* varexp, const char* selection, Option_t* option)
{
	if(CheckIfNullPtr(tree)) return;
	TCanvas* c = new TCanvas();
	tree->Draw(varexp, selection, option);
	TString outputFileName("png/branches/");
	outputFileName += tree->GetName();
	outputFileName += "_";
	outputFileName += varexp;
	outputFileName += ".png";
	c->SaveAs(outputFileName.Data());
	c->Close();
}
void DrawAndSave(TH1D*& hist, const char* saveas)
{
	if(CheckIfNullPtr(hist)) return;
	TCanvas *c = new TCanvas();
	hist->Draw("ep");
	c->SaveAs(saveas);
	delete c;
}
void DrawAndSave(TH2D*& hist, const char* saveas)
{
	if(CheckIfNullPtr(hist)) return;
	TCanvas *c = new TCanvas();
	hist->Draw("colz");
	c->SaveAs(saveas);
	delete c;
}
void DrawSaveAndDelete(TH1D*& hist, const TString& saveas)
{
	if(CheckIfNullPtr(hist)) return;
	DrawAndSave(hist, saveas.Data());
}
void DrawSaveAndDelete(TH1D*& hist, const char* saveas)
{
	if(CheckIfNullPtr(hist)) return;
	DrawAndSave(hist, saveas);
	delete hist;
	hist = nullptr;
}
void DrawSaveAndDelete(TH2D*& hist, const TString& saveas)
{
	if(CheckIfNullPtr(hist)) return;
	DrawAndSave(hist, saveas.Data());
}
void DrawSaveAndDelete(TH2D*& hist, const char* saveas)
{
	if(CheckIfNullPtr(hist)) return;
	DrawAndSave(hist, saveas);
	delete hist;
	hist = nullptr;
}

/**
 * @brief Fit a Gaussian function on a invariant mass distrubution.
 * @details
 * @param invMassHistogram
 * @param particle Hypothesis particle: which particle are you reconstructing?
 * @param sigma This is the assumed with of the Gaussian
 */
void FitGaussian(TH1D* invMassHistogram, const Particle& particle, const double sigma)
{
	// * Check if null pointer and create clone if successful
	if(!invMassHistogram) {
		std::cout << "ERROR: argument is a null pointer" << std::endl;
		return;
	}

	// * Set RooFit fit variable (in this case only the invariant mass axis) *
	double hmin = invMassHistogram->GetXaxis()->GetXmin();
	double hmax = invMassHistogram->GetXaxis()->GetXmax();
	RooRealVar invMassVar("invMassVar", invMassHistogram->GetXaxis()->GetTitle(), hmin, hmax);

	// * Import histogram to Roofit *
	RooDataHist invMassDistribution(invMassHistogram->GetName(), invMassHistogram->GetTitle(), invMassVar, Import(*invMassHistogram));

	// * Create Gaussian function *
	RooRealVar  sigmean ("sigmean",  Form("%s mass",  particle.GetNameLaTeX()),
		particle.GetMass()*1.03, particle.GetMass()*.95, particle.GetMass()*1.05);
	RooRealVar  sigwidth("sigwidth", Form("%s width", particle.GetNameLaTeX()), sigma);
	RooGaussian signal("gauss",
		Form("Gaussian PDF for %s distribution", invMassHistogram->GetXaxis()->GetTitle()),
		invMassVar, sigmean, sigwidth);

	// * Background function *
	double boundary = 30000.;
	RooRealVar p0("p0", "p0", 0., -10000., 10000.);
	RooRealVar p1("p1", "p1", 0., -10000., 10000.);
	RooRealVar p2("p2", "p2", 0., -10000., 10000.);
	RooRealVar p3("p2", "p2", 0., -10000., 10000.);
	RooPolynomial background("background",
		"Background Probability Density Function (PDF)",
		invMassVar, RooArgList(p0, p1, p2, p3));

	// * Fit background + gaussian to the distribution *
	// See https://root.cern.ch/doc/master/classRooAddPdf.html
	RooRealVar nsig("nsig", "number of signal events",     800., 0., boundary);
	RooRealVar nbkg("nbkg", "number of background events",   0., 0., boundary);
	RooAddPdf model("total_distribution", "sig+bck",
		RooArgList(signal, background), RooArgList(nsig, nbkg));
	model.fitTo(invMassDistribution);

	// * Plot results and save *
	RooPlot *frame = invMassVar.frame(); // create a frame to draw
	invMassDistribution.plotOn(frame);   // draw distribution
	model.plotOn(frame);                  // draw sig+bck fit
	model.plotOn(frame, Components(signal),     LineStyle(kDashed), LineColor(kRed));   // draw signal
	model.plotOn(frame, Components(background), LineStyle(kDashed), LineColor(kGreen)); // draw background

	// * Save results *
	TCanvas c;
	frame->Draw();
	c.SaveAs(Settings::Output::Extension+"/"+invMassHistogram->GetName()+"_fit."+Settings::Output::Extension);
}

/**
 * @brief Fit a Breit-Wigner
 * @details
 * @param invMassHistogram
 *
 * @todo Work on Breit-Wigner fit <b>and on its convolution</b>!
 */
void FitBreitWigner(TH1D* invMassHistogram)
{
	// * Check if null pointer and create clone if successful
	if(!invMassHistogram) {
		std::cout << "ERROR: argument is a null pointer" << std::endl;
		return;
	}
	TH1D* hist = dynamic_cast<TH1D*>(invMassHistogram->Clone()); // TODO: needed?
	if(!hist) {
		std::cout << "ERROR: Failed to cast" << std::endl;
		return;
	}

	// * Set RooFit fit variables (in this case only the invariant mass axis) *
	double hmin = hist->GetXaxis()->GetXmin();
	double hmax = hist->GetXaxis()->GetXmax();
	RooRealVar invMassVar("invMassVar", "Invariant mass", hmin, hmax);
	// * Import histogram to Roofit
	RooDataHist invMassDistribution("InvMassDistribution", "Dataset of invariant mass", invMassVar, Import(*invMassHistogram));
	// * Add RooFit distrubution to plotting functionality *
	RooPlot *xframe = invMassVar.frame();
	invMassDistribution.plotOn(xframe);

	// * Create function *
		// * First Gaussian
		RooRealVar  mean1 ("mean1",  "mean of gaussian1",  0);
		RooRealVar  sigma1("sigma1", "sigma of gaussian1", 0.00444); // 0.0019
		RooGaussian gauss1("gauss1", "First gaussian PDF", invMassVar, mean1, sigma1);
		// * Second Gaussian
		RooRealVar  mean2 ("mean2",  "mean of gaussian2",   0);
		RooRealVar  sigma2("sigma2", "sigma of gaussian2",  0.013);
		RooGaussian gauss2("gauss2", "Second gaussian PDF", invMassVar, mean2, sigma2);
		// * Merge the Gaussian components into one Probability Density Function (PDF)
		RooRealVar ngauss1("ngauss1", "event of gauss1", 0.87, 0, 1);
		RooAddPdf  triple_gauss("triple_gauss", "g1+g2+g3", RooArgList(gauss1, gauss2), RooArgList(ngauss1));

	// * Creat Breit-Wigner function *
	RooRealVar mass ("mass",  "mass BW",  0.77, 0.7, 0.8);
	RooRealVar width("width", "width BW", 0.15, 0, 0.2);
	RooBreitWigner bw("bxg", "bxg1", invMassVar, mass, width);

	// * Signal function: the convolution of bw and triple_gauss *
	RooFFTConvPdf signal("signal", "signal", invMassVar, bw, triple_gauss);

	// // * Cackground function (Roopolynomial)
	RooRealVar p0("p0", "p0", -0.5, -100000, 10000);
	RooRealVar p1("p1", "p1",  0.5, -100000, 10000);
	RooRealVar p2("p2", "p2", -0.5, -100000, 100000); //, 100000);
	RooRealVar p3("p3", "p3", -0.5, -100000, 100000); //, 100000);
	RooRealVar p4("p4", "p4", -0.5, -100000, 100000); //, 100000);
	RooPolynomial background("background", "background pdf", invMassVar, RooArgList(p0, p1, p2, p3, p4));
	RooAddPdf total("total_distribution", "sig+bck", signal, background);

	// * Fit invMassDistribution *
	total.fitTo(invMassDistribution);
	signal.plotOn(xframe);
	background.plotOn(xframe);
	total.plotOn(xframe);

	// // * Chebychev function *
	// // RooRealVar p0("p0", "p0",  0.4, -10., 10.);
	// // RooRealVar p1("p1", "p1", -0.4, -10., 10.);
	// // RooRealVar p2("p2", "p2", -0.3, -3.,   3.); // 100000
	// // RooRealVar p3("p3", "p3", -0.2, -3.,   3.); // 100000
	// // // RooRealVar p4("p4", "p4", -0.2, -3., 3.); // 100000);
	// // RooChebychev bkg("bkg", "bkg", invMassVar, RooArgList(p0, p1, p2, p3));

	// // // * Gaussian
	// // 	RooRealVar  amean ("amean",  "mean of gaussian1", 1.35, 1.5, 1.2);
	// // 	RooRealVar  asigma("asigma", "sigma of gaussian", 0.5, 0, 10);//0.0019
	// // 	RooGaussian agaus ("agaus",  "gaussian PDF", invMassVar, amean, asigma);

	// // 	RooRealVar  bmean ("bmean",  "mean of gaussianb", 2, 1.6, 2.3);
	// // 	RooRealVar  bsigma("bsigma", "sigma of gaussian", 1, 0, 10);//0.0019
	// // 	RooGaussian bgauss("bgauss", "gaussian PDF", invMassVar, bmean, bsigma);

	// // 	RooRealVar  cmean ("3mean",  "mean of gaussian1", 2, 1.6, 2.3);
	// // 	RooRealVar  csigma("3sigma", "sigma of gaussian", 1, 0, 10);//0.0019
	// // 	RooGaussian cgauss("3gauss", "gaussian PDF", invMassVar, cmean, csigma);

	// // 	RooRealVar angauss("angauss", "event of gauss", 100, 0, 1000000);
	// // 	RooRealVar bngauss("bngauss", "event of gauss", 100, 0, 1000000);
	// // 	RooRealVar cngauss("cngauss", "event of gauss", 100, 0, 1000000);
	// // 	RooAddPdf  bkg("triple_gauss", "g1+g2+g3", RooArgList(agauss, bgauss, cgauss), RooArgList(angauss, bngauss, cngauss));

	// // // * Signal + sig
	// // 	RooRealVar nfrac ("nfrac", "fraction", 0.244444444, 0, 1);
	// // 	RooRealVar nfrac2("nfrac", "fraction", 0.75555555, 0, 1);
	// // 	RooAddPdf  shape ("shape", "sig+background", RooArgList(signal, bkg, bkg2), RooArgList(nfrac, nfrac2));

	// // // * Fit invMassDistribution *
	// // shape.fitTo(invMassDistribution);

	// // // * Fitted signal.plotOn(xframe, LineWidth(2), LineColor(2));
	// // shape.plotOn( xframe, LineWidth(3), LineColor(2));
	// // shape.plotOn( xframe, Components(signal), LineStyle(kDashed), LineWidth(3), LineColor(3));
	// // shape.plotOn( xframe, Components(bkg), LineStyle(kDashed),LineWidth(3), LineColor(4) );
	// // shape.plotOn( xframe, Components(bkg2), LineStyle(kDashed),LineWidth(3), LineColor(5) );
	// // shape.paramOn(xframe, RooFit::Format("NE",AutoPrecision(1)), RooFit::Layout(0.6, 0.9, 0.9));
	// //shape.paramOn();
	// //xframe->GetYaxis()->SetTitle("Entries/(2.5MeV/c^{2})");
	// xframe->GetYaxis()->SetTitle("event number");
	// //xframe->GetXaxis()->SetTitle("invMassVar(p#bar{p}#pi^{+}#pi^{-})(MeV/#it{c}^{2})");
	// xframe->GetXaxis()->SetTitle("M(#pi^{0}#pi^{-})(GeV/#it{c}^{2})");
	// xframe->GetYaxis()->SetTitleOffset(1.4);
	// //xframe->GetXaxis()->CenterTitle(true);
	// xframe->GetYaxis()->CenterTitle(true);

	// * Draw the fitted function
	TCanvas c;
	xframe->Draw();
	c.SaveAs("TEMP.pdf");

	// * Delete clone *
	// delete hist; // TODO: needed?

}